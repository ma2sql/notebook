## Master Thread (Binlog Dump)의 Mutex 개선
**(작성중)**
5.6버전에서 마스터에서 크래시가 발생하면, 슬레이브에서만 데이터가 존재하는 경우가 발생할 수 있었다. 이유인 즉슨, 몇 개의 트랜잭션을 모아 바이너리 로그를 그룹 커밋으로 처리하는데, 최초에는 디스크 캐시로 데이터를 기록하는 `write` 단계, 그리고 캐시의 내용을 디스크로 플러시하는 `fsync`의 순서로 나누어 처리된다. 문제는 `write`로 바이너리 로그를 기록하는 순간부터 `마스터 스레드(Binlog Dump)`에 의해 읽혀, 슬레이브로 전송될 수가 있는 것이다. 만약, 이 시점에 마스터가 크래시되어 버린다면? 크래시된 마스터를 재기동 이후에는 바이너리 로그가 소실될 가능성이 있고, 그러한 트랜잭션들은 롤백이 될 것이다. 하지만 이미 슬레이브로 전송되어버린 데이터가 있다면 그것은 그대로 슬레이브에만 존재하는 데이터가 되어 버린다. 이러한 문제의 보다 근본적인 원인은 `LOCK_log`
이러한 문제는 5.6.17버전부터는 Lock_log라는 Mutex가 기존에 write까지만 유지했던 잠금을 fsync까지 유지하도록 패치한 이후부터는 해소가 되었다. 문제는 fsync는 디스크로 데이터를 기록하는, 시간이 매우 오래걸리는 작업인데, 이 시간동안 `LOCK_log`가 필요로로 하는 다른 처리들은 모두 대기를 할 수 밖에 없게 되는 것이다. 여러모로 많은 성능상의 단점을 포함하게 되는 패치였는데, 다행히도 5.7부터는 `LOCK_log` 뮤텍스를 사용하는 일부를 `LOCK_binlog_end_pos` 사용하도록 뮤텍스를 보다 세분화하는 형식으로 개선이 되었다. `LOCK_binlog_end_pos` 뮤텍스는 마스터 스레드가 읽을 수 있는 가장 마지막 바이너리 로그 포지션 정보를 보호하는데, 이 포지션 정보는 fsync가 완료된 데이터로 제한된다. ()참고로 이전 버전에서는 EOF, 특별한 제한없이 파일의 모든 부분을 읽을 수가 있었다.)
