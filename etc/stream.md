# Stream

**일괄 처리**
- 입력으로 파일 집합을 읽어 출력으로 새로운 파일 집합을 생성하는 기술이다.
- 출력은 파생 데이터 형태이다.
- 입력되는 데이터의 크기는 유한하며, 모든 처리가 완료된 이후에 결과를 출력한다.
- 처리되는 시간 간격만큼 느린 결과를 받게 된다. (예를 들어, 일별이나 월별)

**스트림 처리**
- 매우 짧은 간격으로 처리
- 또는 고정된 시간이라는 간격이 없이 이벤트가 발생할 때마다 처리하는 것

*스트림이란 시간 흐름에 따라 점진적으로 생산된 데이터*

## 이벤트 스트림 전송
- 스트림의 처리 문맥에서 레코드는 보통 이벤트라고 부른다.
- 이벤트는 텍스트 문자열이나 JSON, 또는 이진 형태 등으로 부호화된다.
- 한 번 기록된 이벤트는 여러 작업에서 읽을 수 있다.
- 생산자 producer가 이벤트를 만들면, 복수의 소비자(consumer)가 처리할 수 있다.
- 토픽(topic)이나 스트림으로 여러 이벤트를 묶을 수 있다.

*생산자 producer 또는 발행자(publisher), 발송자(sender)*
*소비자 consumer 또는 구독자(subscriber), 수신자(recipient)*

### 메시징 시스템(messaging system)
- 생산자는 이벤트를 포함한 메시지를 소비자에게 전달한다.

#### 발행/구독(Publish/Subscribe) 모델
다양한 접근법이 있는데, 그러한 시스템들을 구분하는 2가지 관점
1. 소비자가 메시지를 처리하는 속도보다 생산자가 빠르게 메시지를 전송한다면?
- 메시지를 버리거나
- 큐에 메시지를 버퍼링하거나
- 배압(backpressure). 생산자가 더 이상 메시지를 보내지 못하게 막는다.

*레디스의 경우, 구독자 마다의 출력 버퍼(output buffer)에 저장한다.*

2. 노드가 죽거나 일시적으로 오프라인이 된다면?
- 지속성이 필요하다면? 디스크에 기록하거나 복제본을 생성

*레디스의 경우, 연결이 끊기면 메시지는 버려진다.*

#### 생산자에서 소비자로 메시지를 직접 전달하기
직접 메시징 시스템은 생산자가 직접 소비자에게 메시지를 보낸다.

#### 메시지 브로커
- 메시지 브로커 또는 메시지 큐
- 메시지 브로커는 서버로 구동되며, 생산자와 소비자는 클라이언트로서 연결된다.
- 생산자는 브로커로 메시지를 전달
- 소비자는 브로커로부터 메시지를 받음
- 브로커의 구현에 따라 메시지를 메모리에만 보관하거나, 또는 디스크에 저장하기도 한다.
- 비동기로 동작

#### 메시지 브로커와 데이터베이스의 비교
- 데이터의 보관/삭제
	- 데이터베이스는 명시적으로 삭제될때까지 데이터를 보관
    - 메시지 브로커는 소비자에게 메시지를 전달하면 자동으로 삭제
- 큐/메모리 크기
	- 데이터베이스는 메모리 안에 다 넣을 수 없다면, 디스크를 사용
    - 메시지 브로커는 대부분 메시지를 빠르게 삭제하므로, 큐는 작다
- 색인
	- 데이터베이스는 보조 색인 지원
    - 메시지 브로커는 특정 패턴에 부합하는 토픽의 부분 집합 구독 가능
- 질의
	- 데이터베이스는 스냅샷 기준으로 읽기. 데이터 변경에 대해서는 확인이 어렵기도
    - 메시지 브로커는 데이터 변경에 대해서 클라이언트에게 통지
    
#### 복수 소비자
**로드밸런싱**
- 각 메시지는 소비자 중 **하나**로 전달된다.
**팬 아웃**
- 각 메시지는 **모든** 소비자에게 전달된다.

#### 확인 응답과 재전송
- 소비자가 생산자로부터 전달받은 메시지를 처리했다면, 생산자에게 **확인 응답**을 한다.
	- *레디스의 스트림에서는 XACK*
- 브로커는 확인 응답에 따라서, 처리되지 못한 메시지는 다른 소비자에게 전송하기도 한다.

### 파티셔닝된 로그
- 데이터베이스나 파일시스템은 명시적으로 삭제가 있기 전까지, 데이터를 보관한다.
- 메시지 시스템에서는 메시지가 소비자에게 전달된 후 즉시 삭제한다.

#### 로그를 사용한 메시지 저장소
- 로그 기반 메시지 브로커(log-based message broker): 데이터베이스의 지속성 있는 저장 방법과 메시지 시스템의 지연 시간이 짧은 알림 기능의 조합
- 생산자가 보낸 메시지는 로그 끝에 추가
- 소비자는 로그를 순차적으로 읽어 메시지를 받으며, 로그를 다 읽은 이후에는 새 메시지 추가되었다는 알림을 기다린다.
- 성능을 높이기 위해서 로그를 파티셔닝
  - 독립적으로 읽고 쓰기가 분리된 로그
  - 파티션 내에서는 순서가 보장되나, 파티션 간에는 순서가 보장되지는 않는다.

#### 로그 방식과 전통적인 메시징 방식과의 비교
- 로그 방식 또한 팬아웃 방식을 지원
  - 소비자는 서로 영향없이 독립적으로 로그를 읽을 수 있다. (로그는 삭제되지 않음)
- 파티션 단위로 병렬화가 가능하나, 각각의 파티션은 순차적으로 읽어야 한다.
- 메시지를 처리하는 비용이 비싸고, 메시지 단위로 병렬로 처리를 하고 싶으며, 메시지 순서가 중요하지 않은 경우에는 JMS/AMQP 방식의 메시지 브로커가 적합
- 처리량이 많고, 메시지를 처리하는 속도는 빠르지만, 순서가 중요한 경우에는 로그 방식이 적합

#### 소비자 오프셋
- 오프셋은 데이터베이스 복제에서 쓰이는 Log Sequence Number와 매우 유사
- 개별 메시지마다의 응답 확인을 추적하지 않고, 소비자의 오프셋을 주기적으로 기록
  - 소비자 장애시에 이미 처리했지만 아직 기록하지 못한 오프셋이 있다면, 두 번 처리될 가능성이 있다.

#### 디스크 공간 사용
- 디스크 공간을 재사용하기 위해서, 원형 버퍼(circular buffer) 또는 링 버퍼(ring buffer)를 사용할 수 있다.
- ex) HDD 6TB, Seq 150MB/s => 전체를 모두 사용하기까지 11시간 소요
- 모든 메시지를 디스크에 기록하므로, 처리량은 일정
- 기본적으로 메모리에 대부분의 메시지를 유지하고, 큐가 커질때에만 디스크에 기록하는 시스템은 
  - 큐가 작을 때에는 속도가 매우 빠름
  - 큐가 커져서 디스크에 기록하기 시작하면, 처리량이 매우 떨어짐

#### 소비자가 생산자를 따라갈 수 없을 때
- 로그 방식의 경우에는 "버퍼링" 형태
  - 메시지를 삭제하지 않고 디스크에 모두 기록하며, 링버퍼 형태로 관리
  - 버퍼 크기를 넘어서면 자연스럽게 삭제된다.
- 전통적인 메시지 브로커는 소비자마다 별도의 버퍼를 유지하며, 중단된 경우에는 메모리 낭비를 막기 위해서 삭제해줘야 한다.
  
#### 오래된 메시지 재생
- AMQP/JMS 유형의 메시지 브로커는 메시지 처리/응답 확인 이후, 메시지를 제거한다.
- 로그 방식은 단순히 오프셋의 이동이며, 소비자에 의해 관리된다.
- 일괄 처리와 유사한 측면으로, 동일한 오프셋을 기준으로 몇 번이고 재처리하는 것이 가능하다.


## 데이터베이스와 스트림
- 데이터베이스에의 기록은 이벤트의 발생으로도 볼 수 있다.
- 복제 로그 또한 이벤트의 스트림으로 볼 수 있다.
- 이를 이용하면 여러 시스템을 손쉽게 통합할 수 있다.

### 시스템 동기화 유지하기
- 원본 데이터베이스를 복제하는 데이터웨어하우스
- 동기화 방법
    1. 주기적인 덤프(ETL)
       - 시간이 오래 걸린다.
    2. 이중 기록(dual write)
       - 2PC 등의 복잡한 처리가 필요

### 변경 데이터 캡쳐 (change data capture, CDC)
- 데이터의 변경 사항을 캡쳐해서 검색 색인 등의 다른 시스템에 동기화

#### 변경 데이터 캡쳐의 구현
- 원본 데이터베이스로부터 변경 데이터를 캡쳐하는 방법
    1. 트리거
    2. 복제 로그
- 변경 데이터 캡쳐는 기본적으로 비동기

#### 초기 스냅숏
- 재구축을 위해 모든 변경 사항을 유지하는 것은 어렵기 때문에, 특정 시점의 스냅샷이 필요

#### 로그 컴팩션(log compaction)
- 같은 키의 레코드에 대해서는 가장 최근에 갱신된 내용만 유지 (*마치 AOF의 REWRITE와 같은*)
- 별도로 스냅샷을 유지하지 않고, 데이터베이스 전체의 복사본을 얻을 수 있다.

#### 변경 스트림용 API 지원
- 최근의 데이터베이스는 변경 스트림을 기본 인터페이스로 지원하기 시작
  - 변경이 있을 때, 별도의 이벤트나 알림을 발생
- 카프카 커넥트
  - https://docs.confluent.io/platform/current/connect/index.html
  - https://docs.confluent.io/kafka-connect-redis/current/index.html
  - https://www.slideshare.net/gschmutz/kafka-connect-streams-the-ecosystem-around-kafka

### 이벤트 소싱(Event sourcing)
- CDC와 유사하게 어플리케잉션 상태 변화를 모두 변경 이벤트 로그로 저장한다.
- CDC와의 큰 차이점은 추상화의 레벨이 어플리케이션 쪽에 있다는 것
- 이벤트 소싱의 예
  - 어떤 학생이 강의 신청을 취소한다.
    - 수강 테이블에서 항목 하나를 삭제한다.
    - 학생 피드백 테이블엥서 취소 사유를 추가한다.
  - 책을 주문한다.
    - 장바구니를 생성한다.
    - 책 a를 추가한다.
    - 책 b를 추가한다.
    - 책 b를 삭제한다.
    - 주문한다.

#### 이벤트 로그에서 현재 상태 파생하기
- CDC는 로그 컴팩션 등의 이용하여 최신의 값을 유지할 수 있다.
- 이벤트 소싱은 기록된 모든 이벤트를 재처리해야한다.

#### 명령과 이벤트
- 명령(command)과 이벤트를 구분
- 성공한 명령은 불변의 이벤트가 된다.
- 비행기의 좌석을 예약할 때, 
  - 이미 예약한 사용자이거나, 해당 좌석이 이미 예약되었는지 확인 후,
    - 특정 고객이 특정 좌석을 예약한다라는 이벤트 생성

### 상태와 스트림 그리고 불변성
- 일반적으로 데이터베이스는 현재의 상태를 저장
  - 이벤트 흐름의 가장 마지막 결과
- 변경 로그(change log)를 지속성있게 저장한다면, 불변성의 장점을 얻을 수 있다.
  
> 트랜잭션 로그는 데이터베이스에 적용된 모든 변경 사항을 기록한다. 로그는 고속으로 덧붙여지고, 덧붙이기가 로그를 변경하는 유일한 방법이다. 이런 측면에서 데이터베이스의 내용은 로그의 최근 레코드 값을 캐시하고 있는 셈이다. 즉 로그가 진실이다. 데이터베이스는 로그의 부분 집합의 캐시다. 캐시한 부분 집합은 로그로부터 가져온 각 레코드와 색인의 최신 값이다.

#### 불변 이벤트의 장점
- 금융 부기
  - 거래(transaction)가 발생하면 원장(leader)에 거래 정보를 추가만 한다.
  - 실수가 발생해도, 실수를 보완하는 거래 내역을 추가한다.
- 데이터베이스도 이러한 식으로 불변의 이벤트를 이용하면, 문제를 추적하기 쉬움
- 또한, 개별 이벤트는 유용한 정보가 되기도 함
  - 장바구니에 추가했다가, 삭제한 상품에 대한 정보

#### 동일한 이벤트 로그로 여러 가지 뷰 만들기
- 동일한 이벤트 로그를 이용하여 검색 색인 등의 여러 읽기 전용의 뷰를 만들 수 있다.
- 명령과 질의 책임의 분리, CQRS (Command query responsibility segregation, CQRS)
  - 쓰기: 이벤트 저장소
  - 읽기: 위한 별도의 스냅샷 (RDBMS, etc..)
- 참고: https://engineering-skcc.github.io/microservice%20outer%20achitecture/inner-architecture-Event-Sourcing/

#### 동시성 제어
- 이벤트 로그의 소비는 비동기
  - 발생된 이벤트가 파생된 뷰에 적용되기까지의 과정이 비동기
- 해결 방법
    1. 읽기 뷰와 이벤트 기록을 동기식으로 진행
       - 동일 시스템이라면, 하나의 트랜잭션으로 처리
       - 다른 시스템이라면, 분산 트랜잭션
    2. 이벤트 로그를 재생하여 현재 상태를 만듬

#### 불변성의 한계
- 불변 이벤트를 영구적으로 모두 유지하는 것은 가능할까?
- 사생활 침해 등의 이유로 삭제가 필요할 수도 있다.
  - 또 다른 삭제 이벤트를 추가하는 것이 아닌, 이벤트 스트림 자체에서 삭제되어야 한다.

## 스트림 처리
스트림을 처리하는 방법 3가지
- 이벤트에서 데이터를 꺼내 데이터베이스나 캐시, 검색 색인 또는 유사한 저장소 시스템에 기록하고 다른 클라이언트가 이 시스템에 해당 데이터를 질의한다.
- 이벤트를 사용자에게 직접 보낸다. 이메일 경고, 푸시 알림, 실시간 이벤트 대시보드에 스트리밍
- 하나 이상의 입력 스트림을 처리해 하나 이상의 출력 스트림을 생산

일괄 처리와 스트림의 가장 큰 차이는 스트림은 끝나지 않는다는 것

### 스트림 처리의 사용
모니터링의 목적
- 사기 감시 시스템은 신용카드의 사용 패턴이 기대치 않게 변경되는지 확인해서 도난된 것으로 의심되면 카드 결제를 막는다.
- 거래 시스템은 금융 시장의 가격 변화를 감지해서 특정 규칙에 따라 거래를 실행해야 한다.
- 제조 시스템은 공장의 기계 상태를 모니터링하다 오작동을 발견하면 문제를 빨리 규명해야 한다.
- 군사 첩보 시스템은 잠재적 침략자의 활동을 추적해 공격 신호가 있으면 경보를 발령해야 한다.

#### 복잡한 이벤트 처리 (Complex event processing, CEP)
- 이벤트 스트림 분석용으로 개발된 방법
- 스트림에서 특정 이벤트 패턴을 찾는다.
  - 로그인 해킹 시도 이벤트: 동일한 고객 ID로 5초 동안에 5번 이상의 "로그인 실패 Event"
- 데이터베이스와 비교할 때
  - 데이터베이스는 데이터를 영구적으로 저장하고, 질의를 일시적으로 다룬다.
  - CEP는 질의는 오랜 기간 저장되고 입력 스트림으로부터 들어오는 이벤트가 질의를 지속적으로 지나가면서 이벤트 패턴에 매칭되는 질의를 찾는다.

#### 스트림 분석(analytics)
- CEP와의 경계는 불분명
- 연속한 특정 이벤트 패턴을 찾는 것보다 대량의 이벤트를 집계하고 통계적 지표를 뽑는 것을 우선시
  - 특정 유형의 이벤트 빈도 측정(시간당 얼마나 자주 발생하는지)
  - 특정 기간에 걸친 값의 이동 평균(rolling average) 계산
  - 이전 시간 간격과 현재 통계값의 비교(추세를 감지하거나 지난 주 대비 비정상적으로 높거나 낮은 지표에 대해서 경고)
- 집계 시간 간격은 윈도우(Window)

#### 구체화 뷰 유지하기
- 데이터베이스 변경에 대한 스트림을 캐시, 검색 색인, 데이터 웨어하우스 같은 파생 데이터 시스템에 사용 가능
- 구체화 뷰(Materialized view)

#### 스트림 상에서 검색하기
- 미디어 모니터링 서비스
  - 미디어 아웃렛에서 새 기사와 방송 피드를 구독하고 관심 있는 회사나 상품 또는 주제를 언급하는 뉴스를 검색

#### 메시지 전달과 RPC
- 메시지 전달 시스템을 RPC의 대안으로 사용 가능

### 시간에 관한 추론
- 스트림 처리 프레임워크가 윈도우 시간을 결정할 때, 
  - 장비의 시스템 시간을 이용할지?
  - 이벤트의 시간을 이용할지?
- 예를 들어, 처리가 지연되어 처리 시간과 이벤트 시간의 차이거 커지는 경우에는 문제가 될 수 있다

#### 이벤트 시간 대 처리 시간
- 처리가 지연되는 이유?
  - 큐 대기
  - 네트워크 결함
  - 메시지 브로커나 처리자의 경합
  - 스트림 소비자의 재시작
  - 과거 이벤트의 재처리
- 처리 시간을 기준으로 할 경우, 예를 들어 스트림 처리자의 재배포 후에 백로그를 처리할 때
  - 실제 이벤트 발생 시간은 일정하나,
  - 재시작 시점을 기준으로 일괄적으로 백로그를 처리하므로, 이벤트가 급증하는 듯한 패턴을 보일 수 있다

#### 준비 여부 인식
- 낙오자 이벤트: 네트워크 지연 등으로 어딘가에 버퍼된 이벤트가 제시간에 도착하지 못한 경우
  - 낙오자 이벤트는 무시. 정상적인 상황이라면 적은 비율일 것으로 가정
  - 수정 값을 발행. 낙오자 이벤트가 포함된 윈도우를 기준으로 갱신된 값

#### 어쨌든 어떤 시계를 사용할 것인가?
- 잘못된 장치 시계를 조정하기 위해 세 가지 타임스탬프를 모두 남긴다.
  - 이벤트가 발생한 시간 (장치 시계)
  - 이벤트를 서버로 보낸 시간 (장치 시계)
  - 서버에서 이벤트를 받은 시간 (서버 시계)

#### 윈도우 유형
- 텀블링 윈도우(Tumbling window)
  - 고정된 시간 간격. 윈도우 간에는 중첩되지 않는다.
- 홉핑 윈도우(Hopping window)
  - 고정된 시간 간격. 윈도우 간의 중첩이 가능
- 슬라이딩 윈도우(Sliding window)
  - 이벤트 발생 시간을 기준으로 5분 등의 간격의 윈도우
- 세션 윈도우(Session window)
  - 이벤트 발생 시간을 기준으로 윈도우. 다만 특별히 고정된 기간은 없다.

### 스트림 조인

#### 스트림 스트림 조인(윈도우 조인)
- 특정 사이트에 검색 기능이 있다고 할 때,
  - 이벤트1: 검색이 발생
  - 이벤트2: 검색된 결과에서 특정 url에 대한 클릭이 발생
- 이벤트1에 의해 발생한 이벤트 2를 확인하는 경우, 스트림 간의 조인이 필요

#### 스트림 테이블 조인(스트림 강화)
- 이벤트1: 특정 유저의 어떠한 액션
- 이때, 특정 유저의 프로필도 알고 싶은 경우? 데이터베이스를 참조
- 매번 데이터베이스를 참조하지 않도록, 스트림 처리자 내에 사본을 구축하는 방법도 있음
  - 로컬 사본은 매번 최신으로 갱신될 필요가 있다.

#### 테이블 테이블 조인(구체화 뷰 유지)
- 각각의 이벤트에 대해서 구체화된 뷰를 유지
- 트윗에 대한 타임라인 캐시
  - 사용자a가 새로운 트윗을 보낼 때, a를 팔로잉하는 모든 사용자의 타임라인에 트윗을 추가한다.
  - 사용자a가 트윗을 삭제하면 모든 사용자의 타임라인에서 해당 트윗을 삭제한다.
  - 사용자a가 사용자b를 팔로우하기 시작하면, b의 최근 트윗을 a의 타임라인에 추가한다.
  - 사용자a가 사용자b를 언팔로우할 때, 사용자 b의 최근 트윗을 a의 타임라인에서 삭제한다.

#### 조인의 시간 의존성
- 스트림 파티션 간에는 이벤트의 순서가 보장되지 않으며, 조인 시에 문제가 될 수 있다.
- 예를 들어, 임의의 판매 상품에 대해 국가별 세율 (시간에 따라 다른)
  - 비결정적: 동일한 처리를 반복할 때마다 결과가 달라질 수 있다.
  - 세율/시간에 따라 별도의 식별자를 가지도록 하는 방법

### 내결함성
- 일괄 처리는 재처리를 통해서 
#### 마이크로 일괄 처리와 체크포인트
- 마이크로 일괄 처리(microbatching): 스트림을 작은 블록으로 나누고 일괄 처리를 한다.
- 블록이 클수록 결과를 보기까지 시간이 걸린다.
- 블록이 작을수록 스케줄링과 코디네이션 비용이 커진다.

#### 원자적 커밋 재검토
- 필요한 모든 처리가 성공했을 때만, 출력 또는 부수 효과가 발생하도록 한다.
  - 예를 들어서, 특정 메시지의 처리 후, 이메일 발생

#### 멱등성
- 실패한 태스크의 부분 출력은 버리고, 처음부터 다시 처리
- 멱등 연산의 예
  - 하나의 키에 고정된 특정 값을 설정하는 것은 멱등 연산
  - 하나의 키에 카운터를 증가시키는 것은 멱등 연산이 아니다

#### 실패 후에 상태 재구축하기
- 윈도우 집계나 조인용 테이블에 대한 복구
  - 원격 저장소에 유지한다. (느린 응답)
  - 처리자 내부의 사본 유지 및 주기적 갱신
    - 짧은 윈도우라면 이벤트를 입력 스트림에서 바로 복구
    - 또는, 데이터베이스라면 로그 컴팩션을 이용한 재구축
