---
tags: [redis, stream]
---

# Introduction to Redis Streams

스트림은 레디스 5.0에서 도입된 새로운 데이터 타입이고, 좀 더 추상적인 방법으로 *로그 자료 구조(log data structure)*를 모델링한다. 하지만 로그의 본질은 여전히 남아 있다: 종종 추가 전용 모드의 열린 파일과 같이 구현되는 로그 파일처럼, 레디스 스트림은 주로 추가만 가능한 자료 구조이다. 최소한 개념적으로 레디스 스트림은 메모리에서 표현되는 추상적인 데이터 타입이기 때문에, 로그 파일 그 자체의 한계를 극복하기 위해 좀 더 강력한 오퍼레이션을 구현한다.

자료 구조 그 자체는 매우 단순함에도 불구하고, 레디스 스트림이 가장 복잡한 레디스의 타입인 이유는
추가적이고, 필수적이지 않은 기능을 구현하기 때문이다: 프로듀서에 의해 스트림으로 새롭게 추가된 데이터를 컨슈머가 대기할 수 있도록 하는 블로킹 오퍼레이션의 집합 이외에도, **Consumer Groups**이라고 불리는 개념이 있다.

컨슈머 그룹은 Kafka (TM)이라고 불리는 유명한 메시지 시스템에 의해 처음 도입되었다. 레디스는 완전히 다른 용어로 비슷한 아이디어를 다시 구현하였지만, 목표는 동일하다: 클라이언트의 그룹이 동일한 메시지의 스트림의 각각의 부분을 소비할 수 있도록 협력하게 하는 것이다.

## Streams basics

레디스 스트림이 무엇인지, 그리고 그것을 어떻게 사용하는지 이해하고자 하는 목표를 위해, 우리는 모든 고급 기능들은 무시할 것이고, 대신 자료 구조 그 자체와 조작하고 접근하기 위해 사용되는 커맨드의 측면에 포커스를 맞출 것이다. 이것은 기본적으로 리스트, 셋, 정렬된 셋 등등과 같이 레디스 데이터 타입의 대다수와 공통적인 부분이다. 그러나 리스트 또한 **BLPOP** 등등과 같은 커맨드에 의해 내보내어지는, 좀 더 복잡한 선택적 블로킹 API 옵션을 가지고 있다는 것을 유의해야한다. 그래서 스트림은 이러한 점에서는 리스트보다 크게 다르지 않고, 단지 추가적인 API가 더 복잡하고, 더 강력하다.

스트림은 추가만 가능한 자료 구조이기 때문에, **XADD**라고 불리는 기본적인 쓰기 커맨드는 새로운 엔트리를 지정된 스트림으로 추가한다. 스트림 엔트리는 단순히 문자열이 아니라, 대신 하나 이상의 필드-값의 쌍으로 구성된다. 이러한 방법으로, 여러 개로 나뉘어진 필드가 각 라인에 표현되는 CSV 포맷으로 작성된 파일처럼, 스트림의 각 엔트리는 이미 구조화되어 있다.

```
> XADD mystream * sensor-id 1234 temperature 19.8
1518951480106-0
```

위에서 호출하는 **XADD**커맨드는 커맨드가 반환하는 자동 생성된 엔트리 ID, 구체적으로는 `1518951480106-0`를 이용해서 `sensor-id: 1234, temperature: 19.8` 엔트리를 `mystream`키의 스트림으로 추가한다. 첫 번째 인수로 `mystream`이라는 키를 받고, 두 번째 인수로는 스트림 내에서 모든 엔트리를 식별할 수 있는 엔트리 ID를 받는다. 그러나 이러한 경우에, 우리는 `*` 를 전달할 수 있는데, 왜냐하면 서버가 자동으로 새로운 ID를 생성해주길 바라기 때문이다. 모든 새로운 ID는 단조롭게 증가하고, 그래서 좀 더 단순한 용어로, 새롭게 추가된 엔트리 모두는 모든 지난 엔트리와 비교해서 더 높은 ID를 가질 것이다. 서버에 의해 자동으로 생성된 ID들은 거의 항상 당신이 원하던 것이며, 그리고 명시적으로 지정한 ID에 대한 이유는 매우 드물다. 이것에 대해서는 다음에 좀 더 자세히 이야기할 것이다. 각 스트림 엔트리가 가진 ID는 여타 다른 로그 파일의 라인 번호나 파일 내의 바이트 오프셋과 유사한 것으로, 이는 엔트리를 식별하는데 사용될 수 있다. **XADD** 예제로 돌아가서, 키 이름과 ID의 뒤의 다음 인수들은 스트림 엔트리를 구성하는 필드-값 쌍들이다.

**XLEN** 커맨드만을 이용해서 스트림내의 아이템의 개수를 얻는 것은 가능하다:

```
> XLEN mystream
(integer) 1
```

### Entry IDs

**XADD** 커맨드에 의해 반환되고 스트림 내에서 각 엔트리를 고유하게 식별하는 엔트리 ID는 두 개의 부분으로 구성된다:

```
<millisecondsTime>-<sequenceNumber>
```

밀리초 시간 부분은 ID를 생성하는 로컬 레디스 노드의 실제 로컬 시간이지만, 만약 현재 밀리초 시간이 이전 엔트리보다 더 작으면, 이전 엔트리 시간이 대신 사용된다. 그래서 시간이 뒤쪽으로 이동하더라도, 단조 증가하는 ID 속성은 여전히 유지한다. 이 시퀀스 번호는 동일 밀리초에서 생성된 엔트리에 대해서 사용된다. 시퀀스 번호는 64비트이며, 실질적인 상황에서 동일한 밀리초 내에서 생성되는 엔트리의 수에는 제한이 없다.

이러한 ID의 포맷은 처음에는 이상하게 보일지 모르고, 점잖은 독자는 왜 ID에 시간이 있는지 궁금할 것이다. 이유는 레디스 스트림이 ID를 이용하는 범위 쿼리를 지원하기 때문이다. ID는 엔트리가 생성된 시간과 관련이 있기 때문에, 기본적으로 자유롭게 시간의 범위로 쿼리를 할 수 있게 된다. 우리는 곧 **XRANGE** 커맨드를 다루는 것을 볼 수 있을 것이다.

어떤 이유로 유저가 시간과 관련이 없고 실제로 또 다른 외부 시스템의 ID와 연관되는, 증가하는 ID값이 필요하다면, 이미 앞서 본것과 같이 **XADD** 커맨드는 ID를 자동으로 생성하는 `*` 와일드카드 ID 대신에 명시적인 ID 지정할 수 있다. 다음의 예는 이것을 보여준다:

```
> XADD somestream 0-1 field value
0-1
> XADD somestream 0-2 foo bar
0-2
```

이러한 경우에, 최소 ID는 0-1이고, 이전의 값보다 작거나 같은 ID 값은 받아들이지 않을 것이다:

```
> XADD somestream 0-1 foo bar
(error) ERR The ID specified in XADD is equal or smaller than the target stream top item
```

## Getting data from Streams

이제 우리는 마침내 **XADD**를 통해서 우리의 스트림에 엔트리를 추가할 수 있게 되었다. 하지만, 스트림에 데이터를 추가하는 것은 매우 명백한 반면에 스트림에서 데이터를 추출하기위해 쿼리하는 방법은 아직 명확하지 않다. 만약 아날로그 로그 파일외 비교를 계속해서 해본다면, 한가지 분명한 방법은 일반적으로 사용하는 Unix 커맨드 `tail -f`를 흉내내는 것이고, 그래서 스트림에 새롭게 추가되는 메시지를 얻기 위해 대기를 시작할 것이다. 엘리먼트가 **BLPOP**와 같은 *pop style* 오퍼레이션을 블로킹하는 단일 클라이언트에 도달하는 레디스의 블로킹 리스트 오퍼레이션과는 달리, 마치 여러 `tail -f` 프로세스가 로그에 추가되는 것을 볼 수 있듯이, 스트림을 이용해 여러 컨슈머가 스트림으로 추가되는 새로운 메시지를 볼 수 있기를 원한다. 기존의 용어를 사용해서, 우리는 스트림이 메시지를 여러 클라이언트로 *fan out* 할 수 있기를 원한다.

그러나, 이것은 단지 하나의 잠재적인 액세스 모드이다. 우리는 스트림을 매우 다른 방법으로도 볼 수  있다: 메시징 시스템이 아니라, *시계열 스토어(time series store)*로써. 이러한 경우, 아마 추가되는 새로운 메시지를 얻는 것이 유용할 수도 있지만, 또 다른 자연스러운 쿼리 모드는 시간의 범위로 메시지를 얻거나, 그렇지 않으면 커서를 사용해서 모든 히스토리를 점진적으로 체크하기 위해 메시지를 반복적으러 처리할 수 있다. 이것은 분명히 또 다른 유용한 액세스 모드이다.

결국, 우리가 컨슈머의 관점에서 스트림을 본다면, 스트림을 또 다른 방식으로 접근하기를 원할 수 있는데, 이것은 그러한 메시지를 처리하는 여러 컨슈머로 파티션될 수가 있는 메시지의 스트림으로써, 따라서 컨슈머의 그룹은 단일 스트림에 도착하는 메시지의 서브셋만을 볼 수 있다. 이러한 방법으로, 단일 컨슈머들들이 모든 메시지를 처리할 필요없이, 메시지의 처리를 각각의 컨슈머들로 스케일하는 것이 가능하다: 각각의 컨슈머는 단지 처리할 다른 메시지를 얻을 수 있다. 이것은 기본적으로 Kafka (TM)이 컨슈머 그룹으로 하는 것이다. 컨슈머 그룹을 통해서 메시지를 읽는 것은 레디스 스트림으로부터 데이터를 읽기 위한 매우 흥미로운 또 다른 모드이다.

레디스 스트림은 각각의 다른 커맨드를 통해 위에서 설명한 3가지를 모두 지원한다. 다음 섹션에서 가장 단순하고, 좀 더 직접 사용하기 위한 범위 쿼리를 시작해서 모든 항목을 보여준다.

### Querying by range: XRANGE and XREVRANGE

범위로 스트림에 쿼리하는 것은 *start*와 *end*, 두 개의 ID의 저정만 필요로 한다. 반환되는 범위는 시작이나 끝의 ID를 가지는 엘리먼트를 포함하고, 따라서 범위는 포괄적이다. 두 개의 특별한 ID `-`와 `+`는 대표적으로 사용 가능한 ID중, 가장 작은 값과 가장 큰 값을 의미한다.

```
> XRANGE mystream - +
1) 1) 1518951480106-0
   2) 1) "sensor-id"
      2) "1234"
      3) "temperature"
      4) "19.8"
2) 1) 1518951482479-0
   2) 1) "sensor-id"
      2) "9999"
      3) "temperature"
      4) "18.2"
```

각 엔트리는 두 개의 아이템의 배열을 반환했다: ID와 그리고 필드-값 쌍의 리스트이다. 우리는 이미 엔트리 ID가 시간과 관계를 가진다는 것을 언급했는데, `-` 문자의 왼쪽 부분이 스트림 엔트리를 생성한 로컬 노드의 유닉스 시간(밀리초)이며, 그 시간은 엔트리가 생성된 시간이다. (그러나 스트림이 완전히 (옵션이) 지정된 **XADD** 커맨드로 복제된다. 따라서 슬레이브는 마스터와 동일한 ID를 가진다.)이것은 **XRANGE**를 이용해서 시간의 범위로 쿼리할 수 있다는 것을 의미한다. 그렇게 하기 위해서, 하지만 ID 부분의 시퀀스를 생략하고 싶을 수 있는데: 만약 생략되면, 범위의 시작은 0으로 가정될 것이고, 반면에 마지막 부분은 사용 가능한 최대 시퀀스라고 가정될 것이다. 이러한 방법으로, 밀리초의 유닉스 시간을 2개만은 사용하여 쿼리하는 것으로, 그 시간 범위 안에서 생성된 모든 엔트리를 포괄적인 방식으로 얻을 수 있다. 예를 들어, 사용할 수 있는 2밀리초의 간격으로 쿼리할 것이다.
```
> XRANGE mystream 1518951480106 1518951480107
1) 1) 1518951480106-0
   2) 1) "sensor-id"
      2) "1234"
      3) "temperature"
      4) "19.8"
```

이 시간 범위에서는 하나의 엔트리만을 얻었는데, 하지만 실제 데이터 셋에서는 시간의 범위로 쿼리하거나, 2밀리초 내에 많은 아이템이 있을 수 있고, 반환되는 결과는 매우 클수도 있다. 이러한 이유로, **XRANGE**는 끝 부분에 위치하는, 선택적 옵션인 **COUNT** 를 지원한다. 개수를 지정함으로써, 첫 *N*개의 아이템만을 얻을 수 있다. 만약 좀 더 많은 결과를 원한다면, 반환된 마지막 ID를 얻을 수 있을 것이고, 시퀀스 부분을 1 증가시키고, 다시 쿼리를 한다. 다음의 예에서 이것을 보자. 10개의 아이템을 **XADD**로 추가를 시작한다. (이것을 보여주지는 않으며, 이미 `mystream`은 10개의 아이템을 가지고 있다고 가정한다.) 커맨드당 2개의 아이템을 얻는 반복을 시작하기 위해, 우선 전체 범위로 시작하고, count는 2로 지정한다.

```
> XRANGE mystream - + COUNT 2
1) 1) 1519073278252-0
   2) 1) "foo"
      2) "value_1"
2) 1) 1519073279157-0
   2) 1) "foo"
      2) "value_2"
```

다음 두 아이템에 대한 반복을 계속하기 위해, 앞서 반환된 마지막 ID `1519073279157-0`를 선택하고, ID의 시퀀스 부분을 1 증가시킨다. 시퀀스 번호는 64비트이므로, 오버플로우에 대한 체크는 필요하지 않다. 이러한 경우 요청하는 ID는 `1519073279157-1`이고, 다음 **XRANGE** 호출에 대한 새로운 *start* 인수로 사용될 수 있다:

```
> XRANGE mystream 1519073279157-1 + COUNT 2
1) 1) 1519073280281-0
   2) 1) "foo"
      2) "value_3"
2) 1) 1519073281432-0
   2) 1) "foo"
      2) "value_4"
```

**XRANGE**의 복잡도는 탐색에 대해서는 *O(log(N))*, 그리고 M개의 엘리먼트를 반환에 대해서는 *O(M)* 이다. 작은 수로 실행되는 커맨드는 로그 시간 복잡도를 가지며, 각각의 반복의 단계는 빠르다. 그래서 **XRANGE**는 사실상의 *streams iterator*이고, **XSCAN** 커맨드가 필요하지 않다.

이 커맨드 **XREVRANGE**는 **XRANGE**와 동일하지만, 엘리먼트를 역순으로 반환한다. 그래서 실제적인 사용 용도는 **XREVRANGE**는 스트림 내의 마지막 아이템이 무엇인지 체크하기 위한 것이다:

```
> XREVRANGE mystream + - COUNT 1
1) 1) 1519073287312-0
   2) 1) "foo"
      2) "value_10"
```

**XREVRANGE** 커맨드는 *start*와 *stop* 인수를 역순으로 받는 것을 유의하라.

## Listening for new items with XREAD

스트림 내의 아이템을 범위로 접근하는 것을 원치 않을 때, 보통은 대신 스트림으로 도착한 새로운 아이템을 *구독(subscribe)* 할 수 있기를 원할 것이다. 이 컨셉은 레디스의 Pub/Sub이나 채널을 구독하거나 레디스의 블로킹 리스트, 새로운 엘리먼트를 패치하기 위해 키를 대기하는 레디스의 블로킹 리스트와 관련이 있어 보이지만, 스트림을 소비하는 방법에는 근본적인 차이가 있다:

1. 스트림은 데이터를 기다리는 여러 (컨슈머) 클라이언트를 가질 수 있다. 모든 새로운 아이템은 기본적으로 주어진 스트림내에서 데이터를 기다리는 *모든 컨슈머(every consumer)* 에게 전달된다. 이러한 동작은 각각의 컨슈머가 다른 엘리먼트를 얻는 블로킹 리스트와는 다르다. 하지만 여러 컨슈머로 *fan out*할 수 있는 능력은 Pub/Sub과 비슷하다.
2. Pub/Sub에서 메시지가 *fire and forget(발송하고 지우는?)*과 절대 저장되지 않는, 그리고 블로킹 리스트를 사용할 때, 클라이언트에 의해 수신되는 메시지를 리스트로부터 **꺼내어지는(popped)** (효과적으로 삭제되는) 반면에, 스트림은 근본적으로 다른 방식으로 동작한다. 모든 메시지는 스트림 내에서 무한으로 (뒤로) 추가된다 (사용자가 명시적으로 엔트리들의 삭제를 요청하지 않는다면): 각각의 컨슈머는 마지막으로 수신한 ID를 기억함으로써, 새로운 메시지가 무엇인지를 알 수 있을 것이다.
3. 스트림 컨슈머 그룹은 Pub/Sub이나 블로킹 리스트로는 얻을 수 없는 제어의 레벨을 제공한다. 동일한 스트림을 각각 다른 그룹으로, 처리한 아이템의 명시적인 수신 통보, 보류중인 아이템을 검사할 수 있는 능력, 처리되지 않은 메시지의 소유권을 변경, 각각의 단일 클라이언트에 대해 개별적인 메시지의 지난 히스토리만 볼 수 있는, 일관성있는 히스토리의 가시성 등이 바로 그것이다.

이 커맨드는 스트림으로 도착하는 새로운 메시지의 수신을 대기하는 기능을 제공하며, 이를 **XREAD**라고 부른다. **XRANGE**보다는 조금 더 복잡해서, 단순한 양식부터 보여주기 시작할 것이고, 이후에는 전체 커맨드 레이아웃을 보여줄 것이다.

```
> XREAD COUNT 2 STREAMS mystream 0
1) 1) "mystream"
   2) 1) 1) 1519073278252-0
         2) 1) "foo"
            2) "value_1"
      2) 1) 1519073279157-0
         2) 1) "foo"
            2) "value_2"
```

위는 `XREAD`의 논블로킹(non-blocking)의 형태이다. `COUNT` 옵션은 필수가 아니지만, `STREAMS` 옵션이 필수이다. 이 옵션에는 키의 목록, 그리고 키와 연관이 있는 ID를 함께 지정해야한다. 각각의 ID값은 호출하는 컨슈머가 각각의 스트림에 대해 이미 볼 수 있는 ID의 최대값을 지정해야 한다. 그렇게하면 이 커맨드는 지정된 ID보다 큰 ID의 메시지에 대해서만 클라이언트에게 제공하게 된다.

위 커맨드에서는 `STREAMS mystream 0`을 지정했고, 스트림 `mystream` 내에서 `0-0`보다 큰 ID의 모든 메시지를 얻을 수 있다. 위의 예제에서 볼 수 있듯, 커맨드는 키 네임을 함께 반환한다. 왜냐하면 실제 이 커맨드에 동시에 여러 스트림으로부터 읽기 위해 하나 이상의 키를 지정하여 호출하는 것이 가능하기 때문이다. 예를 들면, 이렇게 지정하는 것이 가능하다. `STREAMS mystream otherstream 0 0`. `STREAMS` 옵션 뒤에 키 네임들과 그 이후에 ID 목록을 지정해야하는 것을 참고하세요. 이러한 이유로 `STREAMS` 옵션은 항상 마지막에 지정해야합니다.

`XREAD`가 한 번에 여러 스트림에 동시에 접근하고, 단지 새로운 메시지를 얻기 위해, 소유한 마지막 ID를 지정할 수 있다는 것 이외에는, 이 심플한 형식은 `XRANGE`와 비교해서 특별하게 차이가 있는 무언가를 하고 있지는 않다. 하지만 흥미로운 부분은 우리는 `XREAD`에 `BLOCK` 인수를 지정해서 쉽게 블로킹 커맨드로 사용할 수 있는 것이다.

```
> XREAD BLOCK 0 STREAMS mystream $
```

위의 예에서, **COUNT**를 제외하는 것 외에도 **BLOCK** 옵션을 타임아웃 0(절대 타임아웃이 되지 않는)과 함께 지정했다. `mystream` 에 대해 일반적인 ID를 전달하는 대신, 특별한 ID인 `$`를 전달했다. 이것은 **XREAD**가 마지막 ID로 `mystream`에 저장되어 있는 값중 가장 큰 ID값을 사용한다는 것을 의미한다. 그리하여 리스닝을 시작하는 시점에서부터 오직 새로운 메시지만 받게 된다. 이것은 유닉스 커맨드인 `tail -f`와 어떤면에서는 비슷한 방식이다.

**BLOCK** 옵션을 사용할 때, 반드시 `$`를 지정할 필요는 없고, 다른 유효한 ID를 지정할 수도 있다. 만약 커맨드가 사용자의 요청을 블로킹 없이 처리할 수가 있다면 그렇게 할 것이고, 아니면 블로킹을 하게 될 것이다. 일반적으로 우리가 스트림을 새로운 엔트리로부터 스트림을 소비하려고 할 때, ID를 `$`로 지정하여 시작하고, 그리고 나서 마지막으로 받은 메시지의 ID를 이용해서 계속해서 다음 요청 등을 실행할 수 있다.

**XREAD**의 블로킹 폼은 단지 키를 여럿 지정함으로써, 여러 스트림으로부터 읽어들이는 것 또한 가능하다. 지정한 ID보다 큰 엘레먼트를 가진 스트림이 적어도 하나가 있어, 요청을 동기식으로 처리할 수 있다면, 결과와 함께 반환될 것이다. 그렇지 않으면, 커맨드는 블로킹될 것이고, (지정된 ID에 따라서) 새로운 데이터를 얻은 첫 스트림의 아이템을 반환할 것이다. 

리스트의 블로킹 오퍼레이션과 마찬가지로, 의미론적으로 FIFO 스타일이기 때문에, 블로킹 스트림은 읽기는 데이터를 기다리는 클라이언트의 관점에서는 공정하다. 주어진 스트림에 대해 블록된 첫 클라이언트는 새로운 아이템이 사용 가능할 때 차단이 해제되는 첫 번째 클라이언트가 된다.

**XREAD**에는 **COUNT**와 **BLOCK**외의 다른 옵션은 없고, 컨슈머를 하나 또는 그 이상의 스트림으로 연결하기 위한 특정한 목적을 가진 매우 기본적인 커맨드다. 스트림을 소비하기 위한 좀 더 강력한 기능은 컨슈머 그룹 API (Consumer Groups API)를 사용함으로써 가능해지는데, 컨슈머 그룹을 통한 읽기는 **XREADGROUP**이라는 또 다른 커맨드에 의해 실현될 수 있다. 이것에 대한 가이드는 다음 섹션에서 다룬다.


## Consumer groups

지금 하고 있는 일이 서로 다른 클라이언트로부터 동일한 스트림을 소비하는 것일때, 그러면 **XREAD** N 클라인트로 팬아웃(fan-out)하는 방법을 이미 제공하고 있고, 읽기 확장성을 제공하기 위해 잠재적으로는 슬레이브를 이용할 수도 있다. 하지만 특정한 상황에서 우리가 원하는 것은 다수의 클라이언트에게 동일한 스트림의 메시지를 제공하는 것이 아니라, 동일한 스트림으로부터 메세지의 **각각 다른 서브셋**을 다수의 클라이언트에게 제공하는 것이다. 이것이 유용한 분명한 경우는 메시지의 처리가 느린 경우이다. 스트림의 각각 다른 부분을 전달받을 수 있는 워커를 N개 가질 수 있다는 것은, 좀 더 많은 일을 할 수 있도록 준비가 된 워커로 메시지를 라우팅함으로써, 메시지의 처리를 확장할 수 있도록 해준다.

현실적으로, 우리가 C1, C2, C3 3개의 컨슈머를 가지고 있고, 스트림 하나는 1,2,3,4,5,6,7의 메시지를 가지고 있다고 상상해보자. 우리가 원하는 것은 다음의 다이어그램과 같이 메시지를 처리하는 것이다.

```
1 -> C1
2 -> C2
3 -> C3
4 -> C1
5 -> C2
6 -> C3
7 -> C1
```

이러한 효과를 얻기 위해서, 레디스는 *consumer groups*라고 불리는 컨셉을 사용한다. 레디스 컨슈머 그룹은 구현의 관점에서 Kafka(TM)의 컨슈머 그룹과 관련이 없다는 것을 이해하는 것은 매우 중요하지만, 구현하는 컨셉의 관점에서는 유사하다. 따라서, 그러한 아이디어를 대중화한 소프트웨어 프로덕트와 비교되는 이 용어를 바꾸지 않기로 했다.

컨슈머 그룹은 스트림으로 데이터를 얻어, 실제 여러 컨슈머에게 전달하는 가상의 컨슈머? (*pseudo consumer*)와 같고, 특정한 보장을 제공한다.

1. 각 메시지는 각각의 컨슈머로 서빙되며, 동일한 메시지가 여러 컨슈머로 전달될 가능성은 없다.
2. 컨슈머는 하나의 컨슈머 그룹 내에서 이름으로 식별되며, 이 이름은 대소문자를 구분하는 문자열로, 컨슈머를 구현하는 클라이언트는 반드시 이름을 지정해야한다. 이것은 심지어 커넥션이 끊긴 이후에도, 스트림 컨슈머 그룹은 모든 상태를 유지, 때문에 클라이트는 다시 동일한 컨슈머가 될 수 있다. 그러나, 물론 이것은 클라이언트가 제공하는 유니크한 식별자에 달려있다.
3. 각 컨슈머는 *first ID never consumed* 라는 컨셉을 가지고 있는데, 컨슈머가 새로운 메시지를 요청할 때, 이전에 결코 전달된 적이 없이 메시지를 전달한다.
4. 메시지를 소비하는 것은 하지만 지정된 커맨드를 이용한 명시적인 응답을 필요로 한다. 말하자면: 이 메시지는 올바르게 처리되었기 때문에, 컨슈머 그룹에서 제거되어도 된다.
5. 컨슈머 그룹은 현재 보류중인 모든 메시지를 추적한다. 메시지가 컨슈머 그룹내의 어떤 컨슈머로 전달이 되었지만, 아직 처리되었다는 응답을 받지 못한 것을 의미한다. 이러한 기능 덕분에 스트림의 메시지 히스토리에 접근할 때, 각 컨슈머는 *오직 자신에게 전달된 메시지만 볼 수 있다.*

어떤 면에서, 컨슈머 그룹은 스트림에 대한 상태 총합의 일부로써 생각해볼 수 있다:

```
+----------------------------------------+
| consumer_group_name: mygroup           |
| consumer_group_stream: somekey         |
| last_delivered_id: 1292309234234-92    |
|                                        |
| consumers:                             |
|    "consumer-1" with pending messages  |
|       1292309234234-4                  |
|       1292309234232-8                  |
|    "consumer-42" with pending messages |
|       ... (and so forth)               |
+----------------------------------------+
```

이러한 관점으로부터 본다면, 컨슈머 그룹이 무엇을 하는지, 어떻게 보류중인 메시지의 히스토리를 컨슈머에게 전달할 수 있는지, 그리고 어떠한 새로운 메시지를 요청하는 컨슈머가 `last_delivered_id` 보다 큰 메시지 ID만을 전달받을 수 있는지, 쉽게 이해할 수 있다. 동시에 레디스의 스트림에 대한 보조적인 자료구조의 측면으로 컨슈머 그룹을 본다면, 하나의 스트림이 여러 컨슈머 그룹을 가질 수 있고, 각각의 컨슈머 그룹을 가질 수 있는 것은 분명하다. 실제로 심지어  동일한 스트림에 대해 컨슈머 그룹없이  **XREAD**를 이용하여 데이터를 읽는 클라이언트와 각각의 컨슈머 그룹에서 **XREADGROUP**을 이용하여 데이터를 읽는 클라이언트를 존재하는 것도 가능하다.

이제, 다음과 같은 기본적인 컨슈머 그룹 커맨드들을 살펴보자.

* **XGROUP**은 컨슈머 그룹을 생성하고, 삭제하고, 관리하는데 사용되는 명령이다.
* **XREADGROUP**은 컨슈머 그룹을 통해 데이터를 읽기 위해 사용되는 명령이다.
* **XACK**은 보류중인 메시지를 올바르게 처리된 것으로 표시할 수 있는 커맨드다.

## Creating a consumer group

만약 `mystream` 이라는 스트림 데이터 타입의 키가 이미 레디스에 저장되어 있다고 할 때, 그룹을 만들기 위해서는 아래와 같이 할 필요가 있다.

```
> XGROUP CREATE mystream mygroup $
OK
```

위의 커맨드에서 보듯이, 컨슈머 그룹을 만들 때에는 ID를 반드시 지정해야하고, 예제에서는 `$`를 지정했다. 이것이 필요한 이유는 각기 다른 상태의 컨슈머 그룹은 첫 번째 컨슈머가 접속할 때, 다음에 제공되어야하는 메시지가 무엇인지에 대한 인식이 있어야하기 때문이고, 그 인식은 그룹이 만들어졌을 때, 현재의 *last message ID*가 무엇인지에 대한 것이다. `$`를 지정한다면, 그때부터 스트림 내에 도착하는 새로운 메시지는 그룹 내의 컨슈머들에게 전달될 것이다. 대신 `0`을 지정한다면, 컨슈머 그룹은 스트림 히스토리의 시작부터 *모든* 메시지를 소비할 것이다. 물론, 다른 유효한 ID를 지정하는 것 또한 가능하다. 알아야할 것은 컨슈머 그룹은 지정된 ID보다 큰 값의 메시지들을 전달하기 시작한다는 것이다. `$`는 현재 스트림 내에서 가장 큰 ID 값을 지정한다는 의미이기 때문에, `$`는 오직 새로운 메시지만 소비하는 효과가 있다.

`XGROUP CREATE`는 마지막 인수로 `MKSTREAM`를 사용해서, 존재하지 않는 스트림을 자동으로 생성하게 하는 것 또한 지원한다.

```
> XGROUP CREATE newstream mygroup $ MKSTREAM
OK
```

이제 컨슈머 그룹이 생성되었기 때문에, 우리는 즉시 컨슈머 그룹에 **XREADGROUP** 커맨드를 사용해서 메시지를 읽어볼 수 있다. 시스템이 Alice와 Bob으로 각각 다른 메시지를 어떻게 반환하는지 알아보기 위해, Alice와 Bob이라고 불리는 컨슈머들로부터 데이터를 읽을 것이다.

**XREADGROUP**은 **XREAD**와 매우 유사하고, 동일한 **BLOCK** 옵션을 제공하는데, 이 부분을 제외하면 동기식 커맨드이다. 그러나 반드시 지정되어야하는 *필수(manatory)* 옵션인 **GROUP**이 있는데, 이 옵션은 컨슈머 그룹의 이름과 읽기를 시도하는 컨슈머의 이름, 2개의 인수를 지정한다. 그리고 **XREAD**와 동일한 **COUNT** 옵션 또한 지원한다.

스트림으로부터 데이터를 읽기 전에, 몇가지 메시지를 입력해보자.

```
> XADD mystream * message apple
1526569495631-0
> XADD mystream * message orange
1526569498055-0
> XADD mystream * message strawberry
1526569506935-0
> XADD mystream * message apricot
1526569535168-0
> XADD mystream * message banana
1526569544280-0
```
참고: *여기의 message는 필드명이고, 과일 이름은 관련된 값이다. 스트림 아이템은 작은 딕셔너리라는 것을 기억하자.*

그렇다면 이제 컨슈머 그룹을 이용해서 무언가를 읽어보자.

```
> XREADGROUP GROUP mygroup Alice COUNT 1 STREAMS mystream >
1) 1) "mystream"
   2) 1) 1) 1526569495631-0
         2) 1) "message"
            2) "apple"
```

**XREADGROUP**의 응답은 **XREAD**의 응답과 동일하다. 그러나 위에서는 `GROUP <group-name> <consumer-name>`이 제공되었는데, 이것은 컨슈머 그룹 `mygroup`을 이용해서 스트림으로부터 데이터를 읽기를 원하고, 컨슈머명은 `Alice`라고 명시했다. 컨슈머가 컨슈머 그룹과 함께 오퍼레이션을 수행하려고 할 때마다, 반드시 그룹 내에서 유니크하게 식별할 수 있는 이름을 지정해야한다.

위의 커맨드 라인에는 또다른 아주 중요한 세부 사항이 있는데, **STREAMS**라는 필수 옵션에 뒤따르는 키 `mystream`에 대해 요청된 ID가 특별한 ID 값인 `>`로 지정된 것이다. 이 특별한 ID는 오직 컨슈머 그룹의 문맥 내에서만 유효하고, 그 의미는 **메시지가 아직까지 결코 다른 컨슈머로 전달된 적이 없다.**이다.

이것은 거의 항상 당신이 원한 것일텐데, 하지만 `0`이나 다른 유효한 ID와 같이 실제 존재하는 ID로 지정하는 것 또한 가능하다. 이러한 경우에 발생하는 것은 우리가 요청한 **XREADGROUP**이 단지 보류중인 메시지의 히스토리를 우리에게 제공하는 것 뿐이고, 이러한 경우에 우리는 그룹 내에서 새로운 메시지를 절대 볼 수 없을 것이다. 그래서 기본적으로 **XREADGROUP**는 우리가 지정한 ID에 기반으로 다음과 같이 동작한다.

* 만약 ID를 특별한 값인 `>`로 지정하면, 커맨드는 이전까지 다른 컨슈머로 절대 전달하지 않은 새로운 메시지만을 반환할 것이고, 부수적으로는 컨슈머 그룹의 *last ID*를 업데이트할 것이다.
* 만약 ID를 유효한 숫자 ID로 지정하면, 커맨드는 우리가 *보류중인 메시지의 히스토리(history of pending messages)*로 접근하게 할 것이다. 그것은, 특정한 컨슈머(전달한 이름에 의해 식별될 수 있는)로 전달된 적이 있는 메시지의 집합이고, 아직까지 **XACK**로 수신에 대한 통지가 없었던 메시지이다.

우리는 **COUNT** 옵션 없이 ID를 0으로 지정해서 이 동작을 즉시 테스트해볼 수 있다. 우리는 오직 보류중인 메시지만을 볼 수 있고, 그것은 사과(apple)에 관한 것이다.

```
> XREADGROUP GROUP mygroup Alice STREAMS mystream 0
1) 1) "mystream"
   2) 1) 1) 1526569495631-0
         2) 1) "message"
            2) "apple"
```

그러나, 만약 우리가 이 메시지가 처리되었다고 통지를 한다면, 더 이상 보류 메시지 히스토리의 일부분이 아니게 되고, 그렇기 때문에 시스템은 더 이상 어떠한 것도 보고하지 않는다.

```
> XACK mystream mygroup 1526569495631-0
(integer) 1
> XREADGROUP GROUP mygroup Alice STREAMS mystream 0
1) 1) "mystream"
   2) (empty list or set)
```

아직 **XACK**가 어떻게 동작하는지 모르더라도, 걱정할 필요가 없다. 컨셉은 처리된 메시지가 더 이상 우리가 접근할 수 있는 히스토리의 일부분이 아니라는 것이다.

이제, Bob으로 무언가를 읽을 차례이다.

```
> XREADGROUP GROUP mygroup Bob COUNT 2 STREAMS mystream >
1) 1) "mystream"
   2) 1) 1) 1526569498055-0
         2) 1) "message"
            2) "orange"
      2) 1) 1526569506935-0
         2) 1) "message"
            2) "strawberry"
```

Bob은 최대 2개의 메시지를 요청했고, 동일하게 `mygroup`을 통해서 데이터를 읽는다. 그렇게 해서 발생하는 일은 Redis가 새로운 메시지를 반환하는 것이다. 위에서 볼 수 있는 것처럼 "apple" 메시지는 전달되지 않으며, 이미 Alice에게 전달된 적이 있기 때문이다. 그래서 Bob은 orange와 strawberry 등등을 얻을 수 있다.

이러한 방법으로 그룹 내의 Alice, Bob, 그리고 다른 컨슈머들은 동일한 스트림으로부터 각각 다른 메시지를 읽을 수 있고, 아직 처리되지 않은 메시지의 히스토리를 읽을 수도 있으며, 또는 메시지를 처리된 것으로 표시할 수 있다. 이것은 스트림으로부터 메시지를 소비하기 위한 별도의 토폴로지와 시맨틱(의미 체계)를 만들 수 있게 한다.

명심해야할 몇 가지가 있다:

* 컨슈머는 처음 언급될 때 자동으로 생성되어, 명시적으로 생성할 필요는 없다.
* **XREADGROUP**으로도 동시에 여러 키를 읽을 수 있지만, 이 기능을 사용하려면, 매 스트림마다 동일한 이름으로 컨슈머 그룹을 만들 필요가 있다. 이것은 보통 필요하지 않지만, 이러한 기능이 기술적으로는 가능하다는 것 정도는 알아둘 가치가 있다.
* **XREADGROUP**은 스트림으로부터 데이터를 읽는 것암에도 *write command*로 분류된다. 데이터의 읽기의 부수적인 효과로 컨슈머 그룹이 변경되기 때문에, 오직 마스터 노드에서만 호출된다.

다음은 컨슈머 그룹을 사용한 컨슈머 구현의 예로, 루비로 작성되었다. 이 루비 코드는 다른 언어로 프로그래밍을 하고, 루비는 잘 모르는 거의 모든 숙련된 프로그래머가 읽을 수 있는 방식으로 작성되었다:

```ruby
require 'redis'

if ARGV.length == 0
    puts "Please specify a consumer name"
    exit 1
end

ConsumerName = ARGV[0]
GroupName = "mygroup"
r = Redis.new

def process_message(id,msg)
    puts "[#{ConsumerName}] #{id} = #{msg.inspect}"
end

$lastid = '0-0'

puts "Consumer #{ConsumerName} starting..."
check_backlog = true
while true
    # Pick the ID based on the iteration: the first time we want to
    # read our pending messages, in case we crashed and are recovering.
    # Once we consumed our history, we can start getting new messages.
    if check_backlog
        myid = $lastid
    else
        myid = '>'
    end

    items = r.xreadgroup('GROUP',GroupName,ConsumerName,'BLOCK','2000','COUNT','10','STREAMS',:my_stream_key,myid)

    if items == nil
        puts "Timeout!"
        next
    end

    # If we receive an empty reply, it means we were consuming our history
    # and that the history is now empty. Let's start to consume new messages.
    check_backlog = false if items[0][1].length == 0

    items[0][1].each{|i|
        id,fields = i

        # Process the message
        process_message(id,fields)

        # Acknowledge the message as processed
        r.xack(:my_stream_key,GroupName,id)

        $lastid = id
    }
end
```

여기서 볼 수 있듯이, 이 아이디어는 히스토리를 소비하는 것으로 시작하고, 그 히스토리는 보류중인 메시지의 리스트이다. 전에 컨슈머가 크래시되어 재시작이 된다면, 우리는 전송은 되었지만 아직 응답(ACK)를 받지 못한 메시지를 다시 읽어야 할 때, 이것은 유용하다. 이 방식으로 우리는 메시지를 여러번 처리하거나 한 번만 처리할 수 있다. (적어도 컨슈머의 실패의 경우, 하지만 레디스의 영속성과 리플리케이션을 포함하는 제한 사항 또한 있다. 이 주제에 대해서는 이후의 섹션을 참고하라.)

한 번 히스토리가 소비되고, 비어있는 메시지 리스트를 받게 되면, 새로운 메시지를 소비하기 위해 `>` 특별 ID로 변경할 수 있다.

## Recovering from permanent failures

위의 예는 메시지의 서브셋 각각을 얻고, 클라이언트로 전달되었지만 아직 보류중인 메시지를 다시 읽어 실패 상태를 복구하는, 동일한 컨슈머 그룹에 참가하는 컨슈머를 작성하도록 해준다. 하지만 현실에서는 컨슈머는 영구적으로 실패하고 절대 복구될 수 없을지도 모른다. 어떠한 이유때문에 멈춘 이후 복구되지 못하는 컨슈머의 보류중인 메시지에는 무슨 일이 발생할까?

레디스 컨슈머 그룹은 이러한 상황에서 주어진 컨슈머의 보류중인 메시지를 클레임(*claim*)하기 위해서 사용할 수 있는 기능으로, 그러한 메시지의 소유권을 변경하고, 다른 컨슈머로 다시 할당한다. 이 기능은 매우 명시적인데, 컨슈머는 보류중인 메시지의 목록을 검사하고, 지정한 메시지를 특별한 커맨드를 이용해서 클레임(claim)해야 하는데, 그렇지 않으면 서버는 영원히 보류중인 메시지를 오래된 컨슈머로 할당해둔다. 이러한 방법으로 각각의 어플리케이션은 이러한 기능을 이용할지 말지, 그리고 정확하게 그 기능을 사용할지를 선택할 수 있다.

이 프로세스의 첫 번째 단계는 단순히 **XPENDING** 커맨드를 이용하는 것이고, 이것은 컨슈머 내의 보류 상태를 관찰할 수 있게 한다. 이것은 read-only 커맨드로, 호출로부터 안전하며 어떤 메시지의 소유권도 변경하지 않는다. 단순한 양식으로, 이 커맨드는 스트림의 이름과 컨슈머 그룹의 이름, 두개의 인수와 함께 호출된다.


```
> XPENDING mystream mygroup
1) (integer) 2
2) 1526569498055-0
3) 1526569506935-0
4) 1) 1) "Bob"
      2) "2"
```

이러한 방식으로 호출될 때, 커맨드는 그룹 내에서 보류중인 메시지의 총 개수를 표시하며, 이번 경우에는 2개의 메시지가 표시된다. 보류중인 메시지의 ID가 제일 작은 것과 큰 것이 표기되며, 마지막으로는 보류중인 메시지를 가진 컨슈머의 리스트와 각각 보유한 보류중의 메시지의 개수를 출력한다. 여기서는 2개의 보류중인 Bob이 표기되는데, Alice가 요청한 메시지에 대해서만 **XACK**를 이용해서 응답이 있었기 때문이다.

**XPENDING**에 더 많은 인수를 주어 더 많은 정보를 요청할 수도 있는데, 전체 커맨드 시그내쳐는 다음과 같기 때문이다.

```
XPENDING <key> <groupname> [<start-id> <end-id> <count> [<consumer-name>]]
```

*시작(start-id) ID*와  *끝 ID(end-id)* (단순히 **XRANGE**와 같이 `-`와 `+`를 부여할 수도 있다.)와 커맨드에 의해 반환될 정보의 전체 수를 제어할 *개수(count-id)* 를 부여함으로써, 우리는 보류중인 메시지에 대해 더 많은 것을 알 수 있다. 선택적인 인수중 마지막인 *컨슈머명(consumer-name)* 은 주어진 컨슈머에 대해서만 보류중인 메시지를 출력하도록 제한하고자 할 때 사용되지만, 다음 예에서 이 기능은 사용하지 않을 것이다. 

```
> XPENDING mystream mygroup - + 10
1) 1) 1526569498055-0
   2) "Bob"
   3) (integer) 74170458
   4) (integer) 1
2) 1) 1526569506935-0
   2) "Bob"
   3) (integer) 74170458
   4) (integer) 1
```

이제 각 메시지에 대한 상세 정보를 확인할 수 있는데, *ID* 와 *컨슈머명*, 컨슈머로 메시지가 전달된 이후, 얼마나 많은 밀리초동안의 시간이 지났는가를 확인할 수 있는 *유휴 시간* , 그리고 마지막으로 *메시지가 전달된 시간* 을 알 수 있다. Bob으로부터 2개의 메시지가 있고, 74170458 밀리초 동안 유효 상태였으며, 이것은 대략 20시간이다.

**XRANGE**만을 이용해서 첫 메시지의 내용이 무엇인지 확인할 수 있는 사람이 아무도 없음을 유의하라.


```
> XRANGE mystream 1526569498055-0 1526569498055-0
1) 1) 1526569498055-0
   2) 1) "message"
      2) "orange"
```

단순히 동일한 ID를 인수로 2번 반복해서 사용해야한다. 이제 우리는 이렇게 생각해볼 수 있는데, Alice는 메시지가 처리되지 않은 20시간 후에도 Bob이 시간내에 복구되지 않을 것이라고 판단할 수 있으며, 그러한 메시지에 대해서는 *claim* 하고, Bob을 대신해서 처리를 재개할 것이다. 그렇게 하기 위해, **XCLAIM** 커맨드를 사용한다.

이 커맨드는 매우 복잡하고, 전체 형식의 옵션으로 가득한데, 컨슈머 그룹의 변경의 복제를 위해 사용되기 때문이다. 하지만 우리는 일반적으로 필요한 인수만을 사용한다. 이러한 경우에 다음과 같이 호출하는 것만큼 간단하다.

```
XCLAIM <key> <group> <consumer> <min-idle-time> <ID-1> <ID-2> ... <ID-N>
```

이 명령으로, 지정한 키와 그룹에 대해 명시된 ID들의 소유권을 변경할 것이고, `<consumer>`에 지정된 컨슈머명으로 할당될 것이라고 말해준다. 그러나 또, 최소한의 유휴 시간을 지정하면, 언급된 메시지의 유휴 시간이 이 커맨드에서 지정한 유휴 시간보다 큰 것에 대해서만 동작하게 된다. 이것은 두 개의 클라이언트가 동시에 메시지를 차지하려고 시도할지도 모르기 때문에 유용하다:

```
Client 1: XCLAIM mystream mygroup Alice 3600000 1526569498055-0
Client 2: XCLAIM mystream mygroup Lora 3600000 1526569498055-0
```

그러나 메시지를 차지(claim)하려고 하는 것의 사이드 이펙트로 메시지의 유휴 시간을 초기화시키는 것이 있다! 그리고 전달된 메시지의 카운트를 증가시킨다. 그래서 두 번째 클라이언트는 클레임에 실패할 것이다. 이러한 방법으로 우리는 메시지의 사소한 재처리를 피할 수 있다. (심지어 일반적으로 정확히 한 번만 처리할 수 없는 경우에도)

이것은 명령의 실행 결과이다:

```
> XCLAIM mystream mygroup Alice 3600000 1526569498055-0
1) 1) 1526569498055-0
   2) 1) "message"
      2) "orange"
```

이 메시지는 Alice에 의해 성공적으로 클레임이 되었고, 그래서 이제 메시지를 처리하고, 메시지를 받았음을 알릴 수 있다(ACK). 그리고 심지어 원래 컨슈머가 복구되지 않고 있더라도 상황을 진전시킬 수 있다.

위의 예로에서 보듯이, 주어진 메시지를 성공적으로 클레임하는 것의 사이드 이펙트로써, **XCLAIM** 커맨드는 또한 메시지를 반환하는 것은 명백하다. 그러나 이것은 필수가 아니다. 성공적으로 클레임된 메시지의 ID만을 리턴하기 위해서 **JUSTID** 옵션이 사용될 수 있다. 서버와 클라이언트간에 사용되는 네트워크 대역폭을 줄이기를 원하거나, 때때로 보류중인 메시지를 다시 스캔하는 방식으로 컨슈머가 구현되어 메시지를 읽을 필요가 없는 경우에는 이 옵션이 유용하다.

클레임하는 것은 단계를 나누어 구현될 수도 있다: 첫 째, 보류중인 메시지의 목록을 체크하고, 유휴 메시지를 활성 상태의 컨슈머로 할당한다. 활성 상태의 컨슈머는 레디스 스트림의 관측 기능의 하나를 사용해서 획득할 수 있다. 이것은 다음 섹션의 주제이다.

## Claiming and the delivery counter

**XPENDING** 출력 결과에서 관측할 수 있는 카운터는 각 메시지의 전송 수이다. 그러한 카운터는 두 가지 방식으로 증가된다: **XCLAIM**에 의해 메시지가 성공적으로 클레임되었을 때, 또는 보류 메시지의 히스토리에 접근하기 위해 **XREADGROUP**이 호출이 사용되는 경우이다.

실패가 있을 때, 메시지가 여러 번 전달되는 것이 일반적이지만, 결국 그 메시지들은 처리되는 것이 보통이다. 하지만 메시지 처리 코드에 버그가 발생하는 식으로 손상되거나 조작되기 때문에, 메시지를 처리하는 데에 문제가 있는 경우가 있다. 그러한 경우 컨슈머는 지속적으로 특정 메시지의 처리에 실패하는 일이 발생할 것이다. 때문에 우리는 전송을 시도에 대한 카운터를 가지고 있고, 어떠한 이유로 전혀 처리가 가능하지 않은 메시지를 발견하는데 이를 사용할 수 있다. 그래서 전송 카운터가 당신이 생각하는 큰 수에 도달하면, 그러한 메시지를 다른 스트림에 넣고, 시스템 관리자에게 알리는 편이 아마 현명할 것이다. 이것은 레디스 스트림이 *dead letter* 라는 컨셉을 구현하는 기본적인 방식이다.

## Streams observability

관측이 부족한 메시징 시스템은 작업하기가 매우 어렵다. 어떤 것이 메시지를 소비하고 있는지, 무슨 메시지가 보류 중인지, 주어진 스트림 내의 컨슈머 그룹의 집합을 알지 못한다면 모든 것이 불투명해진다. 이러한 이유로, 레디스 스트림과 컨슈머 그룹은 무엇이 일어났는지 관측하기 위해서 각각의 방법을 가진다. 이미 다룬 **XPENDING**은 유휴 시간과 전송 회수와 함께 주어진 순간에 처리중인 메시지의 리스트를 검사하게 해준다.

그러나 우리는 그보다 더 많은 것들을 조사할 수 있기를 원할지도 모르며, **XINFO** 커맨드는 스트림이나 컨슈머 그룹에 대한 정보를 얻기 위해 서브 커맨드와 함께 사용될 수 있는 관측가능한  인터페이스이다.

이 커맨드는 스트림과 컨슈머의 상태에 대해 각각 다른 정보를 보여주기 위해 서브 커맨드를 사용한다. 예를 들어, **XINFO STREAM <key>** 는 스트림 자체에 대한 정보를 보고한다.

```
> XINFO STREAM mystream
 1) length
 2) (integer) 13
 3) radix-tree-keys
 4) (integer) 1
 5) radix-tree-nodes
 6) (integer) 2
 7) groups
 8) (integer) 2
 9) first-entry
10) 1) 1526569495631-0
    2) 1) "message"
       2) "apple"
11) last-entry
12) 1) 1526569544280-0
    2) 1) "message"
       2) "banana"
```

이 출력 결과는 어떻게 스트림이 내부적으로 인코딩되었는지에 대한 정보를 보여주고, 또한 스트림내의 첫 번째와 마지막 메시지를 보여준다. 사용할 수 있는 또 다른 정보는 이 스트림의 값과 관련된 컨슈머 그룹의 수이다. 우리는 컨슈머 그룹에 대한 더 많은 정보를 요청함으로써 더 파헤칠 수 있다.

```
> XINFO GROUPS mystream
1) 1) name
   2) "mygroup"
   3) consumers
   4) (integer) 2
   5) pending
   6) (integer) 2
2) 1) name
   2) "some-other-group"
   3) consumers
   4) (integer) 1
   5) pending
   6) (integer) 0
```

이번과 지난 출력 결과에서 볼 수 있듯이, **XINFO** 커맨드는 일련의 필드-값 아이템을 출력한다. 관측 가능한 커맨드이기 때문에, 이것은 무슨 정보가 보고되는지 사람이 즉시 이해할 수 있도록 해주고,  오래된 클라이언트와의 호환성을 헤치지 않고 더 많은 필드를 추가함으로써 미래에는 더 많은 정보를 보고할 수 있도록 해준다. 이외의 커맨드들은 대신 더 효율적으로 대역폭을 사용해야하는 이외의 커맨드들은 단지 필드명 없는 정보만을 보고하면 된다.

**GROUPS** 서브 커맨드가 사용된 위 예의 출력 결과에서 필드명을 명확히 관찰해야 한다. 해당 컨슈머 그룹에 등록된 컨슈머를 체크함으로써 지정한 컨슈머 그룹의 상태의 더욱 상세하게 체크할 수 있다.

```
> XINFO CONSUMERS mystream mygroup
1) 1) name
   2) "Alice"
   3) pending
   4) (integer) 1
   5) idle
   6) (integer) 9104628
2) 1) name
   2) "Bob"
   3) pending
   4) (integer) 1
   5) idle
   6) (integer) 83841983
```

이러한 경우 커맨드의 문법을 기억하지 못한다면, 커맨드 자신에 도움을 요청하라:

```
> XINFO HELP
1) XINFO <subcommand> arg arg ... arg. Subcommands are:
2) CONSUMERS <key> <groupname>  -- Show consumer groups of group <groupname>.
3) GROUPS <key>                 -- Show the stream consumer groups.
4) STREAM <key>                 -- Show information about the stream.
5) HELP                         -- Print this help.
```

## Differences with Kafka (TM) partitions

레디스 스트림의 컨슈머 그룹은 어떠한 형태로 Kafka (TM)의 파티셔닝 기반의 컨슈머 그룹과 닮았을지도 모른다. 하지만 레디스 스트림은 실질적으로 매우 다르다는 것을 참고하라. 파티션은 오직 *논리적(logical)* 이고, 메시지는 단지 하나의 레디스 키에 입력되며, 각각 다른 클라이언트로 제공되는 방법은 어떠한 컨슈머가 새로운 메시지를 처리할 준비가 되었는지에 기반하지, 어떤 파티션 클라이언트가 읽고 있는지는 아니다. 예를 들어, 컨슈머 C3이 어느 시점에 영구적으로 실패하면, 레디스는 이제 2개의 *논리적(logical)*인 파티션만 있는 것처럼, C1과 C2로 도착하는 모든 메시지를 계속해서 전달할 것이다.

마찬가지로, 주어진 컨슈머가 메시지를 처리하는데에 있어 다른 컨슈머보다 훨씬 빠르다면, 이 컨슈머는 동일한 시간 단위 내에서 비례적으로 더 많은 메시지를 받을 것이다. 이것은 레디스가 명시적으로 수신 통지를 받지 못한 모든 메시지를 추적하고, 어떤 컨슈머가 어떤 메시지를 받았는지와 어떤 컨슈머로도 전달된 적이 없는 첫 번째 메시지의 ID를 기억하기 때문이 가능하다.

그러나, 이것은 또한 의미한다. 레디스에서 동일한 스트림의 메시지를 여러 레디스 인스턴스로 파티션하기를 원한다면, 여러 개의 키와, 레디스 클러스터(Redis Cluster)나 어플리케이션 특정(application-specific) 샤딩과 같은 샤딩 시스템을 이용해야 한다. 단일 레디스 스트림은 여러 인스턴스로 자동으로 파티션되지 않는다.

도식적으로 다음과 같은 것이 사실이라고 말할 수 있다.

* 스트림 하나와 컨슈머 하나를 사용한다면, 메시지를 순서대로 처리할 것이다.
* N개의 스트림을 N개의 컨슈머와 함께 사용한다면, 그래서 오직 하나의 컨슈머만 N개의 스트림의 서브셋에 히트하도록 하면, 위의 `1 stream -> 1 consumer` 모델을 확장할 수 있다.
* 하나의 스트림을 N개의 컨슈머로 처리하면, N개의 컨슈머로 로드 밸런싱할 수 있다. 하지만 이러한 경우, 동일한 논리적인 아이템에 대한 메시지는 순서와 상관없이 소비될 것이다. 주어진 컨슈머는 메시지 3를 다른 컨슈머가 처리중인 메시지 4보다 빠르게 처리할지도 모른다.

그래서 기본적으로 카프카 파티션은 N개의 레디스 키를 이용하는 것과 좀 더 비슷하다. 반면에, 레디스 컨슈머 그룹은 메시지를 주어진 스트림 하나로부터 N개의 각각의 컨슈머들로 보내는, 메시지의 서버사이드 로드밸런싱 시스템이다.

## Capped Streams

많은 어플리케이션은 스트림으로 데이터를 영원히 수집하기를 원하지 않을 것이다. 때때로 스트림내의 최대 아이템 개수를 가지는 것이 유용하며, 다른 시점에 최대 사이즈에 도달한다면, 데이터를 레디스로부터 메모리가 아니라 그 만큼 빠르지는 않지만, 잠재적으로 십여년이 될 수도 있는 히스토리를 저장하는데 적합한 스토리지로 옮기는 것이 유용하다. 레디스 스트림은 이를 위한 몇 가지를 지원한다. 하나는 **XADD** 커맨드의**MAXLEN** 옵션이다. 이 옵션을 사용하는 것은 매우 단순한다:

```
> XADD mystream MAXLEN 2 * value 1
1526654998691-0
> XADD mystream MAXLEN 2 * value 2
1526654999635-0
> XADD mystream MAXLEN 2 * value 3
1526655000369-0
> XLEN mystream
(integer) 2
> XRANGE mystream - +
1) 1) 1526654999635-0
   2) 1) "value"
      2) "2"
2) 1) 1526655000369-0
   2) 1) "value"
      2) "3"
```

**MAXLEN**을 사용하면, 지정된 길이에 도달될 때, 오래된 엔트리는 자동으로 제거된다. 따라서 스트림은 일정한 사이즈를 유지한다. 현재는 스트림이 지정된 것보다 더 오래되지 않은 아이템만을  유지하게 하는 옵션이 없기 때문에, 일관성있게 실행되기 위한 이러한 커맨드는 아이템을 제거하기 위해서 많은 시간동안 블로킹을 해야한다. 예를 들어, 입력에 대한 스파이크가 있어, 오랜 시간 동안 멈추고, 또 다른 입력 모두 동일한 최대 시간이 걸린다면 무슨 일이 일어날지 상상해보자. 스트림은  멈춰있는 동안 너무 오래되어 버린 데이터를 제거하기 위해 블록할 것이다. 그래서 이것은 유저가 어떤 계획을 실행하고, 이상적인 스트림의 최대 길이가 무엇인지 이해하는 것에 달려있다. 게다가, 스트림의 길이는 메모리의 사용에 비례하기 때문에, 시간에 의한 트림은 제어와 예측이 덜 간단하다: 입력 비율에 달려있다. 그 비율은 종종 시간에 따라 변하는 변수이다 (그리고 변경이 없다면, 사이즈에 따라 트림하는 것은 간단한 일이다).

그러나 **MAXLEN**으로 트림을 하는 것은 비용이 크다: 스트림은 매우 메모리를 효율적으로 사용하기 위해 매크로(macro) 노드에서 radix 트리로 표현한다. 수십개의 엘리먼트로 구성되는 단일 매크로 노드를 변경하는 것은 최적이 아니다. 그래서 다음과 같이 특별한 형태로 커맨드를 실행하는 것이 가능하다:

```
XADD mystream MAXLEN ~ 1000 * ... entry fields here ...
```

**MAXLEN** 옵션과 실제 개수 사이의 `~` 인수는 정확히 1000개의 아이템일 필요는 없다는 것을 의미한다. 1000이나 1010, 1030이 될 수 있으며, 적어도 1000개의 아이템을 보존하도록 한다. 이 인수를 사용한 트림은 노드 전체를 삭제할 수 있을때만 수행된다. 이것은 훨씬 더 효율적으로 만들어주며, 보통 사람들이 원하는 것이다.

**XTRIM**도 사용가능한데, 이 커맨드는 위에서 **MAXLEN**을 사용한 것과 매우 비슷한 무언가를 수행하지만, 어떠한 것도 입력할 필요가 없으며, 독립적으로 어떠한 스트림에 대해서도 실행될 수 있다.

```
> XTRIM mystream MAXLEN 10
```

또는, **XADD**의 옵션처럼:

```
> XTRIM mystream MAXLEN ~ 10
```

그러나, **XTRIM**은 다른 트림 전략을 받아들일 수 있도록 설계되었다. 하지만 현재까지는 **MAXLEN**만 구현되었다. 이것이 명시적으로 커맨드라는 것을 고려할 때, 향후에는 시간에 의한 트림도 가능해질 것이다. 왜냐하면 독립적인 방식으로 이 커맨드를 호출하는 사용자는 자신이 무엇을 하고 있는지 알고 있기 때문이다.

**XTRIM**이 가져야하는 유용한 제거(eviction)전략 중 하나는, 아마도 ID의 범위로 삭제하는 능력일 것이다. 현재는 가능하지는 않지만, 필요한 경우에 레디스로부터 다른 스토리지 시스템으로 데이터를 옮겨야 할 때, 좀 더 쉽게 **XRANGE**와 **XTRIM**을 함께 사용하기 위해 향후에는 이러한 기능이 구현될 것이다. 

## Special IDs in the streams API

알아차렸을지도 모르지만, 레디스 스트림 API에서 사용될 수 있는몇 가지 특별한 ID가 있다. 여기에 짦은 개요가 있고, 미래에는 좀 더 많은 것들을 이해할 수 있을 것이다.

첫째, `-`와 `+`는 `XRANGE`와 함께 범위 쿼리에 사용된다. 이 두개의 ID는 대표적으로 사용이 가능한 가장 작은 ID(기본적으로 `0-1`)와 가장 큰 ID(`18446744073709551615-18446744073709551615`)를 의미한다. 여기서 볼 수 있듯이, 2개의 숫자 대신 `-`와 `+`를 사용하는 것이 훨씬 더 깔끔하다.

그리고 나서 우리가 이야기하고 싶은 API가 있는데, 그것은 스트림 내에서 가장 큰 ID를 가진 아이템을 뜻하는 ID이다. `$`가 의미하는 것이 이것이다. 그래서 예를 들어, `XREADGROUP`으로 새로운 엔트리만을 얻길 원할 때, (클라이언트/어플리케이션은) 이미 존재하는 엔트리 모두를 가지고 있지만, 미래에 입력될 새로운 엔트리는 없다는 것을 알리기 위해서, 이러한 ID를 사용할 수 있을 것이다. 마찬가지로 컨슈머 그룹의 ID를 설정하거나 생성할 때, 그룹내의 컨슈머로 새로운 엔트리만 전달하기 위해서, 가장 최근에 전달된 아이템을 `$`로 설정할 수 있다.

위에서 볼 수 있듯이, `$`는 `+`를 의미하지는 않는데, 여기에는 2가지 차이점이 있다. `+`는 모든 사용 가능한 모든 스트림내에서 사용 가능한 가장 큰 ID를 의미하고, 반면 `$`는 주어진 엔트리를 포함하는 주어진 스트림내에서 가장 큰 ID를 의미한다. 게다가 API는 보통 `+`나 `$`만을 이해하는데, 아직은 여러 의미를 지닌 심볼이 되는 것은 피하는 것이 유용하다.

또 다른 특별 ID `>`는 오직 컨슈머 그룹하고만 연관이 있고, `XREADGROUP` 커맨드가 사용될 때만 특별한 의미를 가진다. 이러한 특별 ID는 현재까지 다른 컨슈머로 전달된 적이 없는 엔트리만을 의미한다. 따라서 기본적으로 `>` ID는 컨슈머 그룹 내에서 *마지막으로 전달된 ID(last delivered ID)* 이다.

마지막으로 특별 ID `*`는 오직 `XADD` 커맨드와 함께 사용될 수 있으며, 새로운 엔트리에 대한 ID를 자동으로 선택하는 것을 의미한다.

`-`, `+`, `$`, `>`, `*`는 각각 다른 것을 의미하며, 대부분의 상황에 각각 다른 컨텍스트에서 사용될 수 있다.

## Persistence, replication and message safety

레디스 자료 구조와 같이, 하나의 스트림은 비동기적으로 슬레이브로 복제되고, AOF와 RDB로 영구 저장된다. 그러나 명확하지 않을 수도 있는 것은, 컨슈머 그룹의 전체 상태 또한 AOF나 RDB, 슬레이브로 되므로, 만약 마스터에서 메시지가 보류중이면, 슬레이브 또한 동일한 상태 정보를 가진다는 것이다. 마찬가지로, 재시작 이후에 AOF는 컨슈머 그룹 상태를 복원할 것이다.

However note that Redis streams and consumer groups are persisted and replicated using the Redis default replication, so:
그러나 레디스 스트림과 컨슈머 그룹은 영구적으로 저장되고, 레디스의 기본 리플리케이션을 사용해서 복제될 것이라는 것을 참고하라. 그래서:

* 만약 메시지의 영속성이 어플리케이션에 있어서 중요하다면, AOF는 반드시 엄격한 fsync 정책과 함께 사용되어야 한다.
* 기본적으로 비동기 리플리케이션은 **XADD** 커맨드나 컨슈머 그룹이 상태 변경이 복제되는 것을 보장하지는 않을 것이다: 페일 오버 이후에, 마스터로부터 데이터를 전달받는 슬레이브의 능력에 따라서 무언가를 잃어버릴 수도 있다.
* 변경 사항이 슬레이브로 전파되는 것을 강제하기 위해서 **WAIT** 커맨드가 사용될 수 있다. 하지만 이것은 데이터가 손실될 가능성이 매우 낮아지는 반면에, 센티널이나 클러스터에 의해 수행되는 레디스 페일오버 프로세스는 가장 최신의 데이터를 가지는 슬레이브로 페일오버시키기 위해서 *최선의 노력(best effort)*으로 체크만을 수행하고, 특정한 페일 상황에서는 일부 데이터의 누락이 있는 슬레이브를 승격시킬지도 모른다.

그래서 레디스 스트림과 컨슈머 그룹을 사용한 어플리케이션을 설계할 때에는, 실패(장애)동안에 당신의 어플리케이션이 가져야 하는 의미적인 특성을 확실히 이해하고, 적절히 구성해야하며, 당신의 유즈 케이스(use case)가 충분히 안전한지를 평가해야한다.

## Removing single items from a stream

스트림은 또한 ID로 스트림의 중간부터 아이템을 지우기 위한 특별한 커맨드를 가지고 있다. 일반적으로 추가만 가능한 자료 구조에 대해서 이러한 커맨드는 이상한 특징처럼 보일 수 있는데, 실제로 개인 정보 규정과 같은 어플리케이션에는 유용하다. 그러나 사실 유용하다 어플리케이션을 포함하는, 예를 들어, 프라이버시 일반. 이 커맨드는 **XDEL**이고, 스트림의 이름과 함께 삭제할 ID만 필요하다.


```
> XRANGE mystream - + COUNT 2
1) 1) 1526654999635-0
   2) 1) "value"
      2) "2"
2) 1) 1526655000369-0
   2) 1) "value"
      2) "3"
> XDEL mystream 1526654999635-0
(integer) 1
> XRANGE mystream - + COUNT 2
1) 1) 1526655000369-0
   2) 1) "value"
      2) "3"
```

그러나 현재의 구현에서 메크로 노드가 완전히 비어있는 상태가 될때까지, 메모리는 실제 반환되지 않기 때문에, 이 기능을 남용해서는 안된다.

## Zero length streams

스트림과 다른 레디스의 자료구조의 차이는 다른 자료구조는 더 이상 엘레먼트를 가지지 않을 때, 엘레먼트를 삭제하는 커맨드를 호출하는 것의 사이드 이펙트로 키 자신이 삭제되는 것이다. 그래서 예를 들면, 정렬된 셋(Sorted set)은 **ZREM**의 호출이 정렬된 셋의 마지막 엘레먼트를 삭제해야 한다면, (키가) 완전히 삭제될 것이다. 대신 스트림은 (**XADD**와 **XTRIM** 커맨드를) **MAXLEN** 옵션을 0과 함께 사용하거나, **XDEL**이 호출되었을 때, 이 경우 모두 엘레먼트가 없는 상태로 유지하는 것이 허용된다.

왜 이러한 불균형성이 존재하는지에 대한 이유는 스트림이 컨슈머 그룹과 연관되었을지도 모르기 때문이다. 그리고 단지 스트림내에 더 이상 아이템이 없다는 이유로 컨슈머 그룹의 정의 상태를 잃어버려서는 안되기 때문이다. 현재는 스트림이 컨슈머 그룹과 연관이 되어 있지 않다고 하더라도 삭제되지는 않지만, 향후에는 이것은 달라질 수 있다.

## Total latency of consuming a message

`BLOCK` 옵션이 없는 `XRANGE`와 `XREAD`나 `XREADGROUP`와 같은 논블로킹 스트림 커맨드는 다른 레디스 커맨드처럼 동기적으로 처리된다. 그래서 이러한 커맨드의 레이턴시를 논의하는 것은 의미가 없다: 레디스 공식 문서의 커맨드의 시간복잡도를 확인하는 것이 좀 더 흥미롭다. 스트림 커맨드는 범위를 추출할 때에는 적어도 정렬된 셋(Sorted Set)만큼은 빠르고, `XADD` 역시 매우 빠른데, 파이프라인을 사용한다면, 평균적인 머신에서 초당 50만에서 백만 아이템은 쉽게 입력할 수 있다고 충분히 말할 수 있다.

`XADD`를 통해 메시지가 생성되는 순간부터 `XREADGROUP`이 메시지를 함께 반환해서 컨슈머가 메시지를 획득하는 순간까지, 컨슈머 그룹내의 블로킹 컨슈머의 문맥에서 메시지 처리의 딜레이를 알고 싶다면 레이턴시는 흥미로운 파라미터가 될 것이다. 

## How serving blocked consumers work

수행된 테스트의 결과를 제공하기 전에, 레디스가 스트림 메시지를 라우팅하기 위해 무슨 모델을 사용하는지를 이해하는 것은 흥미롭다. (그리고 일반적으로 실제 데이터를 대기하는 블로킹 오퍼레이션이 어떻게 관리되는지)

* 블로킹된 클라이언트는 적어도 하나의 블로킹 컨슈머가 있는 키들을, 그리고 이러한 키들을 대기하고 있는 컨슈머의 리스트로 맵핑을 하고 있는 해시 테이블에서 참고된다. 이러한 방법으로, 데이터를 받는 키가 주어지면, 그러한 데이터를 대기하는 모든 클라이언트를 분석할 수 있다.
* 쓰기가 발생할 때, 이러한 경우 `XADD` 커맨드가 호출되는 때, `signalKeyAsReady()` 함수를 호출한다. 이 함수는 처리를 필요로 하는 키의 리스트에 키를 넣는데, 이는 그러한 키들이 블로킹된 컨슈머를 위한 새로운 데이터를 가질 수도 있기 때문이다. 그러한 *키 (ready keys)*는 이후에 처리될 것이고, 그래서 동일한 이벤트 사이클 중에 키가 다른 쓰기를 받아들이는 것이 가능하다는 점을 유의해야한다.
* 마지막으로, 이벤트 루프로 반환하기 전에, *ready keys*는 마지막으로 처리된다. 각각의 키에 대해서 데이터를 기다리는 클라이언트의 리스트가 실행되고, 만약 해당된다면, 그러한 클라이언트는 도착하는 새로운 데이터를 받게 될 것이다. 스트림의 경우에 데이터는 컨슈머에 의해 요청된 범위에 해당하는 메시지이다.

위에서 보듯, 기본적으로 이벤트 루프로 돌아가기 전에, 메시지를 소비하기 위해 블록된, `XADD`를 호출하는 클라이언트는 출력 버퍼(output buffer)에 응답할 것이고, 그래서 컨슈머가 새로운 메시지를 받는 것과 거의 동시에 `XADD`의 호출 클라이언트는 레디스로부터 응답을 받아야한다.

이 모델은 *푸시 기반(push based)*이며, 데이터를 컨슈머 버퍼로 추가하는 것이 `XADD`를 호출하는 액션에 의해 직접 수행되기 때문이며, 그래서 레이턴시는 매우 예측 가능한 경향이 있다.

## Latency tests results

레이턴시의 특성을 체크하기 위해 테스트가 수행되었고, 이 테스트는 컴퓨터 밀리초 시간을 추가 필드로 가지는 메시지를 푸시하는 루비 프로그램과 컨슈머 그룹으로부터 메시지를 읽고 처리하는 루비 프로그램을 여러 인스턴스를 이용해서 수행되었다. 메시지 처리 단계는 전체 레이턴시를 알기 위해, 현재 컴퓨터 시간과 메시지의 타임스탬프를 비교하는 것으로 구성되었다.

이러한 프로그램은 최적화되지 않은 상황에서 예상할 수 있는 레이턴시의 수치를 제공하기 위해 최적화되지 않았고, 레디스 또한 실행중인 작은 2코어 인스턴스에서 실행되었다. 메시지들은 초당 10k의 비율로 생성되었으며, 10개의 동시에 존재하는 컨슈머는 동일한 레디스 스트림과 컨슈머 그룹으로부터 메시지를 소비하고 받았음을 통지했다.

얻은 결과:

```
Processed between 0 and 1 ms -> 74.11%
Processed between 1 and 2 ms -> 25.80%
Processed between 2 and 3 ms -> 0.06%
Processed between 3 and 4 ms -> 0.01%
Processed between 4 and 5 ms -> 0.02%
```

요청의 99.9%는 레이턴시가 2밀리초와 같거나 작았으며, 평균에 거의 근접한 이상치(outliers)를 가졌다.

통지가 없었던 몇백만의 메시지를 스트림으로 추가하는 것은 벤치마크의 요지를 바꾸지는 않으며, 대부분의 쿼리가 여전히 매우 짧은 레이턴시로 처리된다.

몇 가지 언급:

* 여기에서 매 반복마다 최대 10k의 메시지를 처리했는데, 이것은 `XREADGROUP`의 `COUNT` 파라미터가 10000으로 설정되었다는 것을 의미한다. 이것은 많은 레이턴시를 더했지만, 느린 컨슈머가 메시지의 흐름을 유지할 수 있게 하기 위해서 필요로하다. 따라서 현실에서의 레이턴시는 훨씬 더 작을 것을 기대할 수 있다.
* 이 벤치마크에서 사용한 시스템은 오늘날의 표준과 비교해서 매우 느리다.