Redis Keyspace Notifications
===

**IMPORTANT** Keyspace notifications is a feature available since 2.8.0

Feature overview
---

키 스페이스 노티피케이션(Keyspace notifications)은 클라이언트가 레디스의 데이터 셋이 어떠한 형태로 영향을 받은 이벤트를 수신하기 위해서 `Pub/Sub` 채널을 구독하게 하는 것이다.

수신할 수 있는 이벤트의 예는 다음과 같다.
* 주어진 키에 대해 영향이 있었던 모든 커맨드
* LPUSH 오퍼레이션이르 수신하는 모든 키
* 데이터베이스 0내의 만료중인 모든 키

이벤트는 레디스의 일반적인 Pub/Sub 계층을 이용해서 전달되며, 그렇기 때문에 Pub/Sub을 구현하는 클라이언트는 변경없이 이 기능을 이용하는 것이 가능하다.

레디스 Pub/Sub은 *fire and forget*이기 때문에, 만약 당신의 어플리케이션이 이벤트에 대한 신뢰할 수 있는 통지(**reliable notification**)에 대한 요구가 있다면, 현재는 이 기능을 이용할 방법이 없을 것이다. 당신의 Pub/Sub 클라이언트가 한 번 연결을 끊고 나서 다시 연결을 맺을 때, 클라이언트는 접속이 끊겼던 시간 동안에 전달된 모든 이벤트들을 잃게 된다.

향후에는 좀 더 신뢰할 수 있는 이벤트의 딜리버리가 가능하도록 하려는 계획이 있지만, 아마도 이것은 좀 더 일반적인 수준으로 다루어질 것이다. Pub/Sub 그 자체가 신뢰성을 갖게 되는 것이나, 또는 루아(Lua) 스크립트가 Pub/Sub 이벤트를 리스트로 푸시하는 것과 같은 오퍼레이션을 수행하기 위해 Pub/Sub 메시지를 가로챌 수 있도록 하는 것 등이다.

Type of events
---

키 스페이스 노티피케이션은 레디스 데이터 스페이스에 영향을 주는 모든 오퍼레이션마다 두 가지의 구별되는 형태의 이벤트를 보냄으로써 구현된다. 예를 들어, 데이터베이스 0 안에 있는 `mykey`라고 이름이 붙여진 키에 대한 `DEL` 오퍼레이션은 두 가지 메시지를 발생시킬 것이고, 이는 다음의 두 `PUBLISH` 커맨드와 정확히 동일하다.

```
PUBLISH __keyspace@0__:mykey del
PUBLISH __keyevent@0__:del mykey
```

어떻게 우리는 한 채널로부터 `mykey`에 대한 이벤트를 모두 수신할 수 있는지, 그리고 어떻게 또 다른 채널로부터 `del` 오퍼레이션의 대상이 되는 모든 키에 대한 정보를 얻을 수 있는지를 쉽게 알 수 있을 것이다.

채널 내에서 `keyspace` 프리픽스를 가진 첫 번째 종류의 이벤트는 **키-스페이스 노티피케이션 (key-space notification)** 이라고 부른다. 반면에 `keyevent` 프리픽스를 가진 두 번째 종류의 이벤트는 **키-이벤트 노티피케이션 (key-event notification)** 이라고 부른다.

위의 예에서, `del` 이벤트는 `mykey`에 대해서 발생되었는데, 이에 대해 일어난 일은 다음과 같다.

* Key-space 채널은 이벤트의 이름을 메시지로 수신한다.
* Key-event 채널은 키의 이름을 메시지로 수신한다.

우리가 관심이 있는 이벤트의 일부만을 전달받기 위해, 오직 하나의 종류의 노티피케이션만 활성화하는 것이 가능하다.

Configuration
---

기본적으로 키 스페이스 이벤트 노티피케이션은 비활성화되어 있는데, 이 기능은 눈에 띌 만큼은 아니지만 CPU 자원을 일부 사용하기 때문이다. 노티피케이션은 redis.conf의 `notify-keyspace-events` 옵션을 사용하거나 **CONFIG SET**을 통해서 활성화될 수 있다.

이 파라미터를 빈 문자열로 설정하는 것은 노티피케이션을 비활성화한다. 이 기능을 활성화하기 위해서 비어있지 않은 문자열이 사용되는데, 이 문자열은 여러 문자들로 구성되며, 모든 문자들은 다음의 테이블에 따라 특별한 의미를 가진다:

```
K     Keyspace events, published with __keyspace@<db>__ prefix.
E     Keyevent events, published with __keyevent@<db>__ prefix.
g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...
$     String commands
l     List commands
s     Set commands
h     Hash commands
z     Sorted set commands
t     Stream commands
x     Expired events (events generated every time a key expires)
e     Evicted events (events generated when a key is evicted for maxmemory)
A     Alias for g$lshztxe, so that the "AKE" string means all the events.
```

최소한 `K`나 `E`는 문자열에 지정해야하며, 그렇지 않으면 나머지 문자열에 관계없이 어떠한 이벤트도 전달되지 않는다.

예를 들어, 그저 `LIST`에 대해서만 키 스페이스 이벤트를 활성화하려면, 설정 값은 `Kl`등으로 지정해야만 한다.

`KEA`는 가능한 모든 이벤트를 활성화시키기 위해서 사용될 수 있다.

Events generated by different commands
---

Different commands generate different kind of events according to the following list.
각각의 커맨드는 다음의 목록에 따라 각기 다른 종류의 이벤트를 발생시킨다.

* `DEL` generates a `del` event for every deleted key.
* `DEL`은 모든 삭제되는 키에 대해서 `del` 이벤트를 발생시킨다.
* `RENAME` generates two events, a `rename_from` event for the source key, and a `rename_to` event for the destination key.
* `RENAME`은 두 가지 이벤트를 발생시키는데, 하나는 원본 키에 대한 `rename_from`이벤트이고, 다른 하나는 대상 키에 대한 `rename_to`이벤트이다.
* `EXPIRE` generates an `expire` event when an expire is set to the key, or an `expired` event every time a positive timeout set on a key results into the key being deleted (see `EXPIRE` documentation for more info).
* `EXPIRE`는 키에 대해서 만료 시간(expire)가 설정될 때 `expire`이벤트를 발생시킨거나, 키에 타임아웃이 설정되고, 그 결과로 키가 삭제될 때마다 `expired` 이벤트가 발생하게 된다. (좀 더 많은 정보는 `EXPIRE` 문서를 참고할 것).

* `SORT` generates a `sortstore` event when `STORE` is used to set a new key. If the resulting list is empty, and the `STORE` option is used, and there was already an existing key with that name, the result is that the key is deleted, so a `del` event is generated in this condition.
* `SET` and all its variants (`SETEX`, `SETNX`,`GETSET`) generate `set` events. However `SETEX` will also generate an `expire` events.
* `MSET` generates a separated `set` event for every key.
* `SETRANGE` generates a `setrange` event.
* `INCR`, `DECR`, `INCRBY`, `DECRBY` commands all generate `incrby` events.
* `INCRBYFLOAT` generates an `incrbyfloat` events.
* `APPEND` generates an `append` event.
* `LPUSH` and `LPUSHX` generates a single `lpush` event, even in the variadic case.
* `RPUSH` and `RPUSHX` generates a single `rpush` event, even in the variadic case.
* `RPOP` generates an `rpop` event. Additionally a `del` event is generated if the key is removed because the last element from the list was popped.
* `LPOP` generates an `lpop` event. Additionally a `del` event is generated if the key is removed because the last element from the list was popped.
* `LINSERT` generates an `linsert` event.
* `LSET` generates an `lset` event.
* `LREM` generates an `lrem` event, and additionally a `del` event if the resulting list is empty and the key is removed.
* `LTRIM` generates an `ltrim` event, and additionally a `del` event if the resulting list is empty and the key is removed.
* `RPOPLPUSH` and `BRPOPLPUSH` generate an `rpop` event and an `lpush` event. In both cases the order is guaranteed (the `lpush` event will always be delivered after the `rpop` event). Additionally a `del` event will be generated if the resulting list is zero length and the key is removed.
* `HSET`, `HSETNX` and `HMSET` all generate a single `hset` event.
* `HINCRBY` generates an `hincrby` event.
* `HINCRBYFLOAT` generates an `hincrbyfloat` event.
* `HDEL` generates a single `hdel` event, and an additional `del` event if the resulting hash is empty and the key is removed.
* `SADD` generates a single `sadd` event, even in the variadic case.
* `SREM` generates a single `srem` event, and an additional `del` event if the resulting set is empty and the key is removed.
* `SMOVE` generates an `srem` event for the source key, and an `sadd` event for the destination key.
* `SPOP` generates an `spop` event, and an additional `del` event if the resulting set is empty and the key is removed.
* `SINTERSTORE`, `SUNIONSTORE`, `SDIFFSTORE` generate `sinterstore`, `sunionstore`, `sdiffstore` events respectively. In the special case the resulting set is empty, and the key where the result is stored already exists, a `del` event is generated since the key is removed.
* `ZINCR` generates a `zincr` event.
* `ZADD` generates a single `zadd` event even when multiple elements are added.
* `ZREM` generates a single `zrem` event even when multiple elements are deleted. When the resulting sorted set is empty and the key is generated, an additional `del` event is generated.
* `ZREMBYSCORE` generates a single `zrembyscore` event. When the resulting sorted set is empty and the key is generated, an additional `del` event is generated.
* `ZREMBYRANK` generates a single `zrembyrank` event. When the resulting sorted set is empty and the key is generated, an additional `del` event is generated.
* `ZINTERSTORE` and `ZUNIONSTORE` respectively generate `zinterstore` and `zunionstore` events. In the special case the resulting sorted set is empty, and the key where the result is stored already exists, a `del` event is generated since the key is removed.
* `XADD` generates an `xadd` event, possibly followed an `xtrim` event when used with the `MAXLEN` subcommand.
* `XDEL` generates a single `xdel` event even when multiple entries are are deleted.
* `XGROUP CREATE` generates an `xgroup-create` event.
* `XGROUP DELCONSUMER` generates an `xgroup-delconsumer` event.
* `XGROUP DESTROY` generates an `xgroup-destroy` event.
* `XGROUP SETID` generates an `xgroup-setid` event.
* `XSETID` generates an `xsetid` event.
* `XTRIM` generates an `xtrim` event.
* Every time a key with a time to live associated is removed from the data set because it expired, an `expired` event is generated.
* Every time a key is evicted from the data set in order to free memory as a result of the `maxmemory` policy, an `evicted` event is generated.

**IMPORTANT** all the commands generate events only if the target key is really modified. For instance an `SREM` deleting a non-existing element from a Set will not actually change the value of the key, so no event will be generated.

If in doubt about how events are generated for a given command, the simplest
thing to do is to watch yourself:

    $ redis-cli config set notify-keyspace-events KEA
    $ redis-cli --csv psubscribe '__key*__:*'
    Reading messages... (press Ctrl-C to quit)
    "psubscribe","__key*__:*",1

At this point use `redis-cli` in another terminal to send commands to the
Redis server and watch the events generated:

    "pmessage","__key*__:*","__keyspace@0__:foo","set"
    "pmessage","__key*__:*","__keyevent@0__:set","foo"
    ...



Timing of expired events
---

Keys with a time to live associated are expired by Redis in two ways:

* When the key is accessed by a command and is found to be expired.
* Via a background system that looks for expired keys in background, incrementally, in order to be able to also collect keys that are never accessed.

The `expired` events are generated when a key is accessed and is found to be expired by one of the above systems, as a result there are no guarantees that the Redis server will be able to generate the `expired` event at the time the key time to live reaches the value of zero.

If no command targets the key constantly, and there are many keys with a TTL associated, there can be a significant delay between the time the key time to live drops to zero, and the time the `expired` event is generated.

Basically `expired` events **are generated when the Redis server deletes the key** and not when the time to live theoretically reaches the value of zero.